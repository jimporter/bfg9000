{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"bfg9000 \u00a7 bfg9000 ( \"build file generator\" ) is a cross-platform build configuration system with an emphasis on making it easy to define how to build your software. It converts a Python-based build script into the appropriate files for your underlying build system of choice. Why bfg9000? \u00a7 Familiar syntax \u00a7 build.bfg files are just Python scripts with some new functions added, so you may already know how to write them; and when your build gets complicated, you can rely on the existing Python ecosystem to get you out of trouble. Fast builds \u00a7 bfg9000 ensures your builds are fast by relying on existing, mature build systems like Make and Ninja to do the heavy lifting of building your software; often, incremental builds don't need to execute bfg9000 at all! Stay sane \u00a7 Building your code shouldn't be the hard part of developing your project. Above all else, bfg9000 strives to help you get your build right the first time with many helpful features . A brief example \u00a7 You can't get much simpler than the simplest build.bfg file: executable('simple', files=['simple.cpp']) To build this executable, we need to create the actual build files and then run them: $ cd /path/to/src/ $ 9k build/ $ cd build/ $ ninja From there, you can run your newly-created executable: ./simple . Hooray! For further examples, please see the examples/ subdirectory.","title":"Home"},{"location":"#bfg9000","text":"bfg9000 ( \"build file generator\" ) is a cross-platform build configuration system with an emphasis on making it easy to define how to build your software. It converts a Python-based build script into the appropriate files for your underlying build system of choice.","title":"bfg9000"},{"location":"#why-bfg9000","text":"","title":"Why bfg9000?"},{"location":"#familiar-syntax","text":"build.bfg files are just Python scripts with some new functions added, so you may already know how to write them; and when your build gets complicated, you can rely on the existing Python ecosystem to get you out of trouble.","title":"Familiar syntax"},{"location":"#fast-builds","text":"bfg9000 ensures your builds are fast by relying on existing, mature build systems like Make and Ninja to do the heavy lifting of building your software; often, incremental builds don't need to execute bfg9000 at all!","title":"Fast builds"},{"location":"#stay-sane","text":"Building your code shouldn't be the hard part of developing your project. Above all else, bfg9000 strives to help you get your build right the first time with many helpful features .","title":"Stay sane"},{"location":"#a-brief-example","text":"You can't get much simpler than the simplest build.bfg file: executable('simple', files=['simple.cpp']) To build this executable, we need to create the actual build files and then run them: $ cd /path/to/src/ $ 9k build/ $ cd build/ $ ninja From there, you can run your newly-created executable: ./simple . Hooray! For further examples, please see the examples/ subdirectory.","title":"A brief example"},{"location":"about/changes/","text":"Changes \u00a7 v0.7.0 \u00a7 in progress New features \u00a7 Add support for resolving external package dependencies via mopack Add bfg9000 run command to allow executing other commands using the environment variables for a given build Add support for installing man pages Add --datadir and --mandir configuration options Create compile_commands.json when generating build scripts pkg-config executable can now be found by guessing based on other compilers Compiler and tool objects now have a found property to indicate if they were found on the system Add system flag to package() and pkg_config() to determine whether to treat include directories from packages as system directories Add bfg9000 generate-completion to generate shell-completion functions Add support for CLICOLOR and CLICOLOR_FORCE environment variables to control whether to display colors in terminal output Breaking changes \u00a7 Require Python 3.6+ Qt dependencies are now specified via package('Qt', '<component>') rather than package('Qt<component>') bfg9000 no longer automatically installs patchelf on Linux systems Bug fixes \u00a7 Error reporting now shows the proper stack frames on Windows Fix detection of clang-cl compiler MinGW can now use libraries of the form name.lib Paths with basenames of . or .. are now treated as directories Improve support for detecting tool versions when generating MSBuild files Empty strings as command-line arguments (e.g. in command ) are now properly quoted pkg-config .pc files now always use POSIX-like paths Fix display of the traceback in a bfg file when building from the build directory Replace packaging dependency with verspec for future stability v0.6.0 \u00a7 2020-09-12 New features \u00a7 Add support for including multiple build.bfg (and options.bfg ) files from subdirectories via submodule() Create -uninstalled variants of generated pkg-config .pc files and allow build scripts to use them internally Add opts.gui to generate graphical programs (important on Windows) Add opts.static to request static linking of libraries MSVC's runtime can now be selected by using a combination of opts.static and opts.debug MSVC linker now automatically links to default Windows libraries ( kernel32.lib , etc) Link steps ( executable , library , etc) now accept an extra_compile_deps argument to forward on to the compilation step Allow customizing install locations for specific files via the directory argument Iterables passed to default or install will include each element of the iterable in the appropriate build target info() , debug() , and warning() now take a variable number of arguments to print generated_source() steps are now automatically created as necessary for files passed to object_file() , if possible Add path_exists() builtin Paths with a trailing / are now treated as directory paths, and when passed to auto_file() will create a directory object Add support for compiling Windows .rc files Add support for setting the entry point for native binaries (C, C++, etc) The default list of excluded globs for find_files() can now be customized via project(find_exclude=[...]) Try to find the right compiler to use for C-family languages by guessing based on other compilers in the family (e.g. if CXX=g++ , guess that the C compiler is gcc ) Add support for DESTDIR on Windows when installation paths don't include a drive letter Regenerating build files with the Ninja backend now uses the console pool, allowing realtime output and colored text Breaking changes \u00a7 Drop support for Python 2 find_files() and find_paths() have been redesigned to support recursive globs pkg_config() now defaults to auto_fill=False resource_file() has been deprecated; use source_file() instead show_stack for info() and debug() must now be specified as a keyword argument directory , and header_directory now require uncommon arguments to be specified as keyword arguments Adding to existing environment variables in env.execute() and env.run() is now done via extra_env , not env / env_update Bug fixes \u00a7 copy_file() now works correctly when copying into a subdirectory on the Make backend extra_deps now works with copy_file() Calling exit() with a non-zero return code from a build.bfg file now causes configuration to fail Automatically-generated PCH source files (for MSVC compilers) are now placed in the same directory as the resulting PCH The contents of header directories in the build directory are now installed to the base include directory The install_name for libraries on macOS is now always an absolute path, instead of using @rpath -based paths prior to installation MSBuild backend can now build libraries with no source files that link to a whole-archive library Object files with unrecognized source languages can now be linked with the default linker for their object format .stamp files generated by the Make backend are now properly removed when running make clean Fix sudo prompt when installing to a system directory with the Ninja backend v0.5.1 \u00a7 2019-12-07 Bug fixes \u00a7 Depfiles generated by compile steps are now properly included into Makefiles Include directories passed to via include and libraries passed via libs are now listed before those from packages when building Fix linking to shared libraries located in the source directory v0.5.0 \u00a7 2019-11-25 New features \u00a7 Add generated_source() to allow generating source code from domain-specific languages Add support for lex , yacc , and Qt build tools ( moc , rcc , uic ) Add the ability to use placeholders for build_step() and command() Add an auto_file() function that infers the kind of file based on its extension; build_step() now uses this by default for outputs Add always_outdated argument to build_step() Add copy_file() and copy_files() functions default() now returns the files passed into it install() now returns the installed forms of the files passed into it Add safe_str() and safe_format() to help safely build command string Expose Path object to bfg scripts Add directory as an option for object_file() , generated_source() , copy_file() , and their list-variants Add lang and intermediate_dirs arguments to project() for modifying project-wide settings Add srcdir builtin to toolchain files Breaking changes \u00a7 find_files() redesigned and split into find_files() and find_paths() ; simple cases should still work, but more complex uses will need adjusted pkg-config .pc files generated by bfg9000 no longer include rpath flags Explicitly passing lang to a build step now overrides the languages of any input files when determining the builder args and kwargs no longer supported for build_step() ; use a lambda instead Options specified on the command line (e.g. install locations) now override settings in toolchain files Implicitly-defined object files (e.g. those generated by executable() ) are placed in an intermediate directory; call project(intermediate_dirs=False) to disable this Bug fixes \u00a7 Include options.bfg in dist tarballs Fix escaping of ~ in Makefiles Symbolic links (e.g. from versioned shared libraries) are now properly installed as symlinks Generated header directories are now included as dependencies of compilation steps Default install locations are now based on the target platform instead of the host platform Shared libraries with soversion s can now be used with pkg_config() v0.4.1 \u00a7 2019-07-05 Bug fixes \u00a7 Fix using semantic options in global_options v0.4.0 \u00a7 2019-07-05 New features \u00a7 Compilers and linkers now support semantic options, abstracting away the differences between compiler flavors Add support for cross-compilation Toolchain files can be used to simplify setting up build configuration options Add info , warn , and debug builtins to let build scripts print messages via bfg's logging system whole_archive() now works with MSVC linkers Add support for module-definition files when linking .exe or .dll files Build steps now have a (customizable) friendly description when using the Ninja backend Makefiles generated by bfg now have a clean target Breaking changes \u00a7 MSVC builds now automatically set /EHsc to improve standards-compliance and mimic Visual Studio's default MSBuild configuration Paths are now parsed in a platform-agnostic manner, which may cause issues for certain esoteric pathnames (e.g. POSIX paths that look like Windows paths) env.platform has been split into env.host_platform and env.target_platform MinGW now makes DLLs named <name>.dll instead of lib<name>.dll Platform names are reworked; 'windows' is now 'winnt' and 'darwin' is 'macos' Bug fixes \u00a7 Fix support for packaging as a Python Wheel Default options for ar are now cr instead of cru to support versions of ar that default to deterministic builds Fix building Java projects with OpenJDK 8+ Fix loading Boost packages from C:\\Boost on Windows Libraries are linked via their absolute paths where possible to help disambiguate libraries with the same name v0.3.1 \u00a7 2018-06-01 Bug fixes \u00a7 Fix an issue with creating the build directory during the configuration process v0.3.0 \u00a7 2018-06-01 New features \u00a7 Replace system_package() and pkgconfig_package() with a generic package resolver: package() Add headers argument to package() to find header files and libs to specify library names if pkg-config lookup fails Support Java/Scala Add support for user-defined arguments Add a library() function that builds shared and/or static libraries per the user's preference Add support for generating pkg-config .pc files Allow executing files that require an interpreter or other wrapper via command() or test() / test_driver() without explicitly specifying the wrapper; supports all languages buildable by bfg9000, plus Lua, Perl, Python, and Ruby Add env.run() , env.execute() , and env.run_arguments() to simplify executing programs during configuration Add a framework() function to specify macOS frameworks to use for a build Improve detection of compiler flavors by checking version information Automatically colorize clang/gcc output under Ninja Add support for uninstalling builds Add static_link_options to static_library() to specify options to pass to the static linker Add a bfg9000 env command to print the environment variables used during configuration Automatically request sudo elevation when installing builds to a system directory Breaking changes \u00a7 directory() and header_directory() no longer automatically include all files within them (pass include='*' for the old behavior) The include argument for compiling object files has been replaced by includes When creating a static library, link_options now specifies options that will be forwarded along to the dynamic linker, rather than options for the static linker itself The options argument for test() / test_driver() has been deprecated; add any options to the first argument ( cmd ) instead test() no longer converts its first argument to a generic_file() Splitting POSIX shell strings (used for compile and link options as well as environment vars on POSIX like CPPFLAGS ) no longer parses escape characters Bug fixes \u00a7 Improve logging of syntax errors in build.bfg files Fix usage of nested shared libraries when linking with GNU ld (via -rpath-link ) Installing directories from the srcdir now correctly installs their contents to the installation root for that type (e.g. a header directory of foo/bar installs its contents to $includedir ) Fix generation of dependencies for the tests target Improve escaping for paths when using Make on Windows (previously users had to escape backslashes themselves) Fix an issue with quotation marks being stripped for some commands on Windows with the Ninja backend v0.2.0 \u00a7 2016-06-26 New features \u00a7 Support Objective C/C++ Partially support Fortran (simple projects work, but more complex things probably don't) Improved error reporting Warn users if necessary build tools can't be found by bfg9000 Automatically include runtime dependencies when installing a binary Support @rpath on OS X Allow fetching bfg's version from build.bfg files via bfg9000_version Support versioning of shared libraries on POSIX systems Support resolving packages via pkg-config Locally-built static libraries now forward their options to binaries that link to them whole_archive() now forwards its arguments on to static_library() Use doppel for installing files instead of install(1) Support command() and alias() rules under MSBuild Add support for building a distribution of the sources ( make dist ) Allow running custom build steps via build_step() Breaking changes \u00a7 Configuring a build is now performed by bfg9000 configure DIRECTORY header() renamed to header_file() env.compiler(lang) replaced by env.builder(lang).compiler env.linker(lang, mode) replaced by env.builder(lang).linker(mode) env.compiler(lang).flavor replaced by env.builder(lang).flavor Bug fixes \u00a7 Fix fetching CFLAGS from the environment (it used to try CCFLAGS ) Fix execution context of build.bfg files; this caused strange issues with list/generator comprehensions v0.1.1 \u00a7 2016-01-21 Fix an issue with installing the package from PyPI v0.1.0 \u00a7 2016-01-20 Initial release Support for C and C++ builds on Linux, Mac, and Windows (MinGW included) via Make, Ninja, and MSBuild.","title":"Changes"},{"location":"about/changes/#changes","text":"","title":"Changes"},{"location":"about/changes/#v070","text":"in progress","title":"v0.7.0"},{"location":"about/changes/#new-features","text":"Add support for resolving external package dependencies via mopack Add bfg9000 run command to allow executing other commands using the environment variables for a given build Add support for installing man pages Add --datadir and --mandir configuration options Create compile_commands.json when generating build scripts pkg-config executable can now be found by guessing based on other compilers Compiler and tool objects now have a found property to indicate if they were found on the system Add system flag to package() and pkg_config() to determine whether to treat include directories from packages as system directories Add bfg9000 generate-completion to generate shell-completion functions Add support for CLICOLOR and CLICOLOR_FORCE environment variables to control whether to display colors in terminal output","title":"New features"},{"location":"about/changes/#breaking-changes","text":"Require Python 3.6+ Qt dependencies are now specified via package('Qt', '<component>') rather than package('Qt<component>') bfg9000 no longer automatically installs patchelf on Linux systems","title":"Breaking changes"},{"location":"about/changes/#bug-fixes","text":"Error reporting now shows the proper stack frames on Windows Fix detection of clang-cl compiler MinGW can now use libraries of the form name.lib Paths with basenames of . or .. are now treated as directories Improve support for detecting tool versions when generating MSBuild files Empty strings as command-line arguments (e.g. in command ) are now properly quoted pkg-config .pc files now always use POSIX-like paths Fix display of the traceback in a bfg file when building from the build directory Replace packaging dependency with verspec for future stability","title":"Bug fixes"},{"location":"about/changes/#v060","text":"2020-09-12","title":"v0.6.0"},{"location":"about/changes/#new-features_1","text":"Add support for including multiple build.bfg (and options.bfg ) files from subdirectories via submodule() Create -uninstalled variants of generated pkg-config .pc files and allow build scripts to use them internally Add opts.gui to generate graphical programs (important on Windows) Add opts.static to request static linking of libraries MSVC's runtime can now be selected by using a combination of opts.static and opts.debug MSVC linker now automatically links to default Windows libraries ( kernel32.lib , etc) Link steps ( executable , library , etc) now accept an extra_compile_deps argument to forward on to the compilation step Allow customizing install locations for specific files via the directory argument Iterables passed to default or install will include each element of the iterable in the appropriate build target info() , debug() , and warning() now take a variable number of arguments to print generated_source() steps are now automatically created as necessary for files passed to object_file() , if possible Add path_exists() builtin Paths with a trailing / are now treated as directory paths, and when passed to auto_file() will create a directory object Add support for compiling Windows .rc files Add support for setting the entry point for native binaries (C, C++, etc) The default list of excluded globs for find_files() can now be customized via project(find_exclude=[...]) Try to find the right compiler to use for C-family languages by guessing based on other compilers in the family (e.g. if CXX=g++ , guess that the C compiler is gcc ) Add support for DESTDIR on Windows when installation paths don't include a drive letter Regenerating build files with the Ninja backend now uses the console pool, allowing realtime output and colored text","title":"New features"},{"location":"about/changes/#breaking-changes_1","text":"Drop support for Python 2 find_files() and find_paths() have been redesigned to support recursive globs pkg_config() now defaults to auto_fill=False resource_file() has been deprecated; use source_file() instead show_stack for info() and debug() must now be specified as a keyword argument directory , and header_directory now require uncommon arguments to be specified as keyword arguments Adding to existing environment variables in env.execute() and env.run() is now done via extra_env , not env / env_update","title":"Breaking changes"},{"location":"about/changes/#bug-fixes_1","text":"copy_file() now works correctly when copying into a subdirectory on the Make backend extra_deps now works with copy_file() Calling exit() with a non-zero return code from a build.bfg file now causes configuration to fail Automatically-generated PCH source files (for MSVC compilers) are now placed in the same directory as the resulting PCH The contents of header directories in the build directory are now installed to the base include directory The install_name for libraries on macOS is now always an absolute path, instead of using @rpath -based paths prior to installation MSBuild backend can now build libraries with no source files that link to a whole-archive library Object files with unrecognized source languages can now be linked with the default linker for their object format .stamp files generated by the Make backend are now properly removed when running make clean Fix sudo prompt when installing to a system directory with the Ninja backend","title":"Bug fixes"},{"location":"about/changes/#v051","text":"2019-12-07","title":"v0.5.1"},{"location":"about/changes/#bug-fixes_2","text":"Depfiles generated by compile steps are now properly included into Makefiles Include directories passed to via include and libraries passed via libs are now listed before those from packages when building Fix linking to shared libraries located in the source directory","title":"Bug fixes"},{"location":"about/changes/#v050","text":"2019-11-25","title":"v0.5.0"},{"location":"about/changes/#new-features_2","text":"Add generated_source() to allow generating source code from domain-specific languages Add support for lex , yacc , and Qt build tools ( moc , rcc , uic ) Add the ability to use placeholders for build_step() and command() Add an auto_file() function that infers the kind of file based on its extension; build_step() now uses this by default for outputs Add always_outdated argument to build_step() Add copy_file() and copy_files() functions default() now returns the files passed into it install() now returns the installed forms of the files passed into it Add safe_str() and safe_format() to help safely build command string Expose Path object to bfg scripts Add directory as an option for object_file() , generated_source() , copy_file() , and their list-variants Add lang and intermediate_dirs arguments to project() for modifying project-wide settings Add srcdir builtin to toolchain files","title":"New features"},{"location":"about/changes/#breaking-changes_2","text":"find_files() redesigned and split into find_files() and find_paths() ; simple cases should still work, but more complex uses will need adjusted pkg-config .pc files generated by bfg9000 no longer include rpath flags Explicitly passing lang to a build step now overrides the languages of any input files when determining the builder args and kwargs no longer supported for build_step() ; use a lambda instead Options specified on the command line (e.g. install locations) now override settings in toolchain files Implicitly-defined object files (e.g. those generated by executable() ) are placed in an intermediate directory; call project(intermediate_dirs=False) to disable this","title":"Breaking changes"},{"location":"about/changes/#bug-fixes_3","text":"Include options.bfg in dist tarballs Fix escaping of ~ in Makefiles Symbolic links (e.g. from versioned shared libraries) are now properly installed as symlinks Generated header directories are now included as dependencies of compilation steps Default install locations are now based on the target platform instead of the host platform Shared libraries with soversion s can now be used with pkg_config()","title":"Bug fixes"},{"location":"about/changes/#v041","text":"2019-07-05","title":"v0.4.1"},{"location":"about/changes/#bug-fixes_4","text":"Fix using semantic options in global_options","title":"Bug fixes"},{"location":"about/changes/#v040","text":"2019-07-05","title":"v0.4.0"},{"location":"about/changes/#new-features_3","text":"Compilers and linkers now support semantic options, abstracting away the differences between compiler flavors Add support for cross-compilation Toolchain files can be used to simplify setting up build configuration options Add info , warn , and debug builtins to let build scripts print messages via bfg's logging system whole_archive() now works with MSVC linkers Add support for module-definition files when linking .exe or .dll files Build steps now have a (customizable) friendly description when using the Ninja backend Makefiles generated by bfg now have a clean target","title":"New features"},{"location":"about/changes/#breaking-changes_3","text":"MSVC builds now automatically set /EHsc to improve standards-compliance and mimic Visual Studio's default MSBuild configuration Paths are now parsed in a platform-agnostic manner, which may cause issues for certain esoteric pathnames (e.g. POSIX paths that look like Windows paths) env.platform has been split into env.host_platform and env.target_platform MinGW now makes DLLs named <name>.dll instead of lib<name>.dll Platform names are reworked; 'windows' is now 'winnt' and 'darwin' is 'macos'","title":"Breaking changes"},{"location":"about/changes/#bug-fixes_5","text":"Fix support for packaging as a Python Wheel Default options for ar are now cr instead of cru to support versions of ar that default to deterministic builds Fix building Java projects with OpenJDK 8+ Fix loading Boost packages from C:\\Boost on Windows Libraries are linked via their absolute paths where possible to help disambiguate libraries with the same name","title":"Bug fixes"},{"location":"about/changes/#v031","text":"2018-06-01","title":"v0.3.1"},{"location":"about/changes/#bug-fixes_6","text":"Fix an issue with creating the build directory during the configuration process","title":"Bug fixes"},{"location":"about/changes/#v030","text":"2018-06-01","title":"v0.3.0"},{"location":"about/changes/#new-features_4","text":"Replace system_package() and pkgconfig_package() with a generic package resolver: package() Add headers argument to package() to find header files and libs to specify library names if pkg-config lookup fails Support Java/Scala Add support for user-defined arguments Add a library() function that builds shared and/or static libraries per the user's preference Add support for generating pkg-config .pc files Allow executing files that require an interpreter or other wrapper via command() or test() / test_driver() without explicitly specifying the wrapper; supports all languages buildable by bfg9000, plus Lua, Perl, Python, and Ruby Add env.run() , env.execute() , and env.run_arguments() to simplify executing programs during configuration Add a framework() function to specify macOS frameworks to use for a build Improve detection of compiler flavors by checking version information Automatically colorize clang/gcc output under Ninja Add support for uninstalling builds Add static_link_options to static_library() to specify options to pass to the static linker Add a bfg9000 env command to print the environment variables used during configuration Automatically request sudo elevation when installing builds to a system directory","title":"New features"},{"location":"about/changes/#breaking-changes_4","text":"directory() and header_directory() no longer automatically include all files within them (pass include='*' for the old behavior) The include argument for compiling object files has been replaced by includes When creating a static library, link_options now specifies options that will be forwarded along to the dynamic linker, rather than options for the static linker itself The options argument for test() / test_driver() has been deprecated; add any options to the first argument ( cmd ) instead test() no longer converts its first argument to a generic_file() Splitting POSIX shell strings (used for compile and link options as well as environment vars on POSIX like CPPFLAGS ) no longer parses escape characters","title":"Breaking changes"},{"location":"about/changes/#bug-fixes_7","text":"Improve logging of syntax errors in build.bfg files Fix usage of nested shared libraries when linking with GNU ld (via -rpath-link ) Installing directories from the srcdir now correctly installs their contents to the installation root for that type (e.g. a header directory of foo/bar installs its contents to $includedir ) Fix generation of dependencies for the tests target Improve escaping for paths when using Make on Windows (previously users had to escape backslashes themselves) Fix an issue with quotation marks being stripped for some commands on Windows with the Ninja backend","title":"Bug fixes"},{"location":"about/changes/#v020","text":"2016-06-26","title":"v0.2.0"},{"location":"about/changes/#new-features_5","text":"Support Objective C/C++ Partially support Fortran (simple projects work, but more complex things probably don't) Improved error reporting Warn users if necessary build tools can't be found by bfg9000 Automatically include runtime dependencies when installing a binary Support @rpath on OS X Allow fetching bfg's version from build.bfg files via bfg9000_version Support versioning of shared libraries on POSIX systems Support resolving packages via pkg-config Locally-built static libraries now forward their options to binaries that link to them whole_archive() now forwards its arguments on to static_library() Use doppel for installing files instead of install(1) Support command() and alias() rules under MSBuild Add support for building a distribution of the sources ( make dist ) Allow running custom build steps via build_step()","title":"New features"},{"location":"about/changes/#breaking-changes_5","text":"Configuring a build is now performed by bfg9000 configure DIRECTORY header() renamed to header_file() env.compiler(lang) replaced by env.builder(lang).compiler env.linker(lang, mode) replaced by env.builder(lang).linker(mode) env.compiler(lang).flavor replaced by env.builder(lang).flavor","title":"Breaking changes"},{"location":"about/changes/#bug-fixes_8","text":"Fix fetching CFLAGS from the environment (it used to try CCFLAGS ) Fix execution context of build.bfg files; this caused strange issues with list/generator comprehensions","title":"Bug fixes"},{"location":"about/changes/#v011","text":"2016-01-21 Fix an issue with installing the package from PyPI","title":"v0.1.1"},{"location":"about/changes/#v010","text":"2016-01-20 Initial release Support for C and C++ builds on Linux, Mac, and Windows (MinGW included) via Make, Ninja, and MSBuild.","title":"v0.1.0"},{"location":"about/license/","text":"License \u00a7 BSD 3-clause license \u00a7 Copyright (c) 2015-2023, Jim Porter All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"about/license/#license","text":"","title":"License"},{"location":"about/license/#bsd-3-clause-license","text":"Copyright (c) 2015-2023, Jim Porter All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"BSD 3-clause license"},{"location":"developer/backends/","text":"Build Backends \u00a7 bfg9000 supports generating files for multiple build tools, called \"backends\". These are specified in the bfg9000.backends entry point ; third parties can add support for their own backend by hooking into this. Warning Currently, custom build steps aren't supported as builtins ; however, support is planned, and any third-party backend will need to decide which (if any) custom build steps they'd like to support. How a build.bfg file is compiled \u00a7 Before we get started looking at how each bakend works, let's quickly go over how a build.bfg file is compiled at a high level. At its core, a build file is just a DAG (directed acyclic graph) that gets walked through by the build system, where the nodes are files and the edges are build steps. A bfg9000 build file is no different. Snapshot the environment \u00a7 When bfg9000 is invoked, it first takes a snapshot of the current environment (the operating system, environment variables, compiler to use, etc). This is important to provide a stable state for regeneration of the build file if necessary (e.g. if build.bfg is changed). Build an internal dependency graph \u00a7 Next, it executes the build.bfg file. Most bfg9000 functions represent build steps or other related parts of the dependency graph. When called, these build up an internal DAG structure with all the backend-agnostic data filled in (e.g. virtual filenames are resolved to real ones, such as \"foo\" to \"libfoo.so\"). Emit the final build file \u00a7 Once this is complete, the DAG is passed to the appropriate backend, which iterates over all the known edges (build steps) and emits the backend-specific code for them. Since all the backends handle walking the DAG on their own, bfg9000 can safely avoid worrying about trying to do this efficiently in Python. Public API for backends \u00a7 backend.write( env , build_inputs ) \u00a7 Called when bfg9000 has finished building its internal dependency graph and it's time to generate the backend-specific build files. env is an Environment object and build_inputs is a BuildInputs object containing the internal dependency graph. build_inputs.edges() returns a list of Edge s that correspond to each build step defined in the build.bfg file. backend.priority \u00a7 The priority of this build backend. This helps determine the default backend. The default is the backend with the highest priority that's also \"valid\" (i.e. backend.version() returns a non- None value). backend.version() \u00a7 Return the version (as a verspec.loose.Version object -- also aliased as bfg9000.versioning.Version ) of this build backend's underlying tool. If the tool can't be found (or is otherwise broken), this returns None .","title":"Build Backends"},{"location":"developer/backends/#build-backends","text":"bfg9000 supports generating files for multiple build tools, called \"backends\". These are specified in the bfg9000.backends entry point ; third parties can add support for their own backend by hooking into this. Warning Currently, custom build steps aren't supported as builtins ; however, support is planned, and any third-party backend will need to decide which (if any) custom build steps they'd like to support.","title":"Build Backends"},{"location":"developer/backends/#how-a-buildbfg-file-is-compiled","text":"Before we get started looking at how each bakend works, let's quickly go over how a build.bfg file is compiled at a high level. At its core, a build file is just a DAG (directed acyclic graph) that gets walked through by the build system, where the nodes are files and the edges are build steps. A bfg9000 build file is no different.","title":"How a build.bfg file is compiled"},{"location":"developer/backends/#snapshot-the-environment","text":"When bfg9000 is invoked, it first takes a snapshot of the current environment (the operating system, environment variables, compiler to use, etc). This is important to provide a stable state for regeneration of the build file if necessary (e.g. if build.bfg is changed).","title":"Snapshot the environment"},{"location":"developer/backends/#build-an-internal-dependency-graph","text":"Next, it executes the build.bfg file. Most bfg9000 functions represent build steps or other related parts of the dependency graph. When called, these build up an internal DAG structure with all the backend-agnostic data filled in (e.g. virtual filenames are resolved to real ones, such as \"foo\" to \"libfoo.so\").","title":"Build an internal dependency graph"},{"location":"developer/backends/#emit-the-final-build-file","text":"Once this is complete, the DAG is passed to the appropriate backend, which iterates over all the known edges (build steps) and emits the backend-specific code for them. Since all the backends handle walking the DAG on their own, bfg9000 can safely avoid worrying about trying to do this efficiently in Python.","title":"Emit the final build file"},{"location":"developer/backends/#public-api-for-backends","text":"","title":"Public API for backends"},{"location":"developer/backends/#backend-write","text":"Called when bfg9000 has finished building its internal dependency graph and it's time to generate the backend-specific build files. env is an Environment object and build_inputs is a BuildInputs object containing the internal dependency graph. build_inputs.edges() returns a list of Edge s that correspond to each build step defined in the build.bfg file.","title":"backend.write(env, build_inputs)"},{"location":"developer/backends/#backend-priority","text":"The priority of this build backend. This helps determine the default backend. The default is the backend with the highest priority that's also \"valid\" (i.e. backend.version() returns a non- None value).","title":"backend.priority"},{"location":"developer/backends/#backend-version","text":"Return the version (as a verspec.loose.Version object -- also aliased as bfg9000.versioning.Version ) of this build backend's underlying tool. If the tool can't be found (or is otherwise broken), this returns None .","title":"backend.version()"},{"location":"developer/builtins/","text":"Builtins \u00a7 Note Builtins aren't currently extendable by third parties. However, this is planned . bfg9000 provides a set of builtin functions, classes, and variables to build scripts so that projects can easily describe their build process. These are all defined in bfg9000/builtins/ ; each file is automatically imported and its builtins are added to a dict of globals to pass to build.bfg . Decorators \u00a7 Builtins are defined by using decorators defined in bfg9000.builtins.builtin ; by default, these make the decorated object available to build.bfg , but you can also specify the context to change where the object is available: 'build' for build.bfg files, 'options' for options.bfg files, 'toolchain' for <toolchain>.bfg files, and '*' for all files; in addition, you can specify a list of any of these strings to add the object to multiple contexts. @default([ context ], [ name ]) \u00a7 Define a function (or other callable object, including a type) as a builtin for the specified context s. If name is passed, it will be used as the builtin's name; otherwise, the function's name will be used. @function([ context ], [ name ]) \u00a7 Define a function (or other callable object) as a builtin for the specified context s. If name is passed, it will be used as the builtin's name; otherwise, the function's name will be used. When called by a bfg script, the function will be passed a context object as the first argument. @getter([ context ], [ name ]) \u00a7 Define a getter function as a builtin for the specified context s. If name is passed, it will be used as the builtin's name; otherwise, the function's name will be used. When called by a bfg script, the function will be passed a context object as the first argument. @post([ context ], [ name ]) \u00a7 Define a function to be run after the user's build script is executed for the specified context s. When called after a bfg script, the function will be passed a context object its only argument. @type( out_type , [ in_type ], [ extra_in_type ], [ short_circuit ], [ first_optional ]) \u00a7 Define the return type of the decorated function as out_type and accepting automatic conversion of any object of in_type or extra_in_type (either a type or tuple of types, defaulting to string_or_path_types ) as the first argument. If short_circuit is true (the default), passing in an object of type out_type will simply return the input with no changes. If first_optional is true, calling the decorated function with a single positional argument will pass None as the first argument, and the supplied argument as the second. This decorator is primarily useful for autoconversion of strings to the corresponding object for one of a build step's arguments (e.g. converting 'foo.cpp' to a SourceFile ). Context objects \u00a7 Context objects contain all the necessary data to manage the internal state corresponding to a bfg script. These can be used by builtins to work with the environment, add build steps to the graph, etc.","title":"Builtins"},{"location":"developer/builtins/#builtins","text":"Note Builtins aren't currently extendable by third parties. However, this is planned . bfg9000 provides a set of builtin functions, classes, and variables to build scripts so that projects can easily describe their build process. These are all defined in bfg9000/builtins/ ; each file is automatically imported and its builtins are added to a dict of globals to pass to build.bfg .","title":"Builtins"},{"location":"developer/builtins/#decorators","text":"Builtins are defined by using decorators defined in bfg9000.builtins.builtin ; by default, these make the decorated object available to build.bfg , but you can also specify the context to change where the object is available: 'build' for build.bfg files, 'options' for options.bfg files, 'toolchain' for <toolchain>.bfg files, and '*' for all files; in addition, you can specify a list of any of these strings to add the object to multiple contexts.","title":"Decorators"},{"location":"developer/builtins/#default","text":"Define a function (or other callable object, including a type) as a builtin for the specified context s. If name is passed, it will be used as the builtin's name; otherwise, the function's name will be used.","title":"@default([context], [name])"},{"location":"developer/builtins/#function","text":"Define a function (or other callable object) as a builtin for the specified context s. If name is passed, it will be used as the builtin's name; otherwise, the function's name will be used. When called by a bfg script, the function will be passed a context object as the first argument.","title":"@function([context], [name])"},{"location":"developer/builtins/#getter","text":"Define a getter function as a builtin for the specified context s. If name is passed, it will be used as the builtin's name; otherwise, the function's name will be used. When called by a bfg script, the function will be passed a context object as the first argument.","title":"@getter([context], [name])"},{"location":"developer/builtins/#post","text":"Define a function to be run after the user's build script is executed for the specified context s. When called after a bfg script, the function will be passed a context object its only argument.","title":"@post([context], [name])"},{"location":"developer/builtins/#type","text":"Define the return type of the decorated function as out_type and accepting automatic conversion of any object of in_type or extra_in_type (either a type or tuple of types, defaulting to string_or_path_types ) as the first argument. If short_circuit is true (the default), passing in an object of type out_type will simply return the input with no changes. If first_optional is true, calling the decorated function with a single positional argument will pass None as the first argument, and the supplied argument as the second. This decorator is primarily useful for autoconversion of strings to the corresponding object for one of a build step's arguments (e.g. converting 'foo.cpp' to a SourceFile ).","title":"@type(out_type, [in_type], [extra_in_type], [short_circuit], [first_optional])"},{"location":"developer/builtins/#context-objects","text":"Context objects contain all the necessary data to manage the internal state corresponding to a bfg script. These can be used by builtins to work with the environment, add build steps to the graph, etc.","title":"Context objects"},{"location":"developer/contributing/","text":"Contributing \u00a7 So, you've found an issue with bfg9000 or have an idea to improve it? Great! This page will provide you with some useful information to help you get started. Filing an issue \u00a7 Before contributing a patch, it's best to file an issue to discuss your plan. This will help ensure that you've got a good idea of the best way to go about things and don't go down the wrong path to start. Setting up a development environment \u00a7 Like most other Python-based projects, the easiest way to set up a development environment for bfg9000 is to use pip to install an editable version of the package. You'll probably also want all the testing dependencies, which you can install with the test extra: $ pip install -e '.[test]' Running tests \u00a7 bfg9000 has a suite of tests to ensure that everything works properly. (Well, everything that has tests!) As you may expect, you can run these via: $ python setup.py test If you'd like to run a subset of tests, such as when trying to fix a bug in a specific area of the code, you can limit the tests that get run. For instance, to run only the tests in test/integration/test_simple.py , you can type: $ python setup.py test -s test.integration.test_simple To generate a coverage report, simply replace test with coverage , and build the report in the format you want, e.g.: $ python setup.py coverage && coverage html Linting code \u00a7 bfg9000 uses flake8 for linting. You can check this with the lint command like so: $ python setup.py lint","title":"Contributing"},{"location":"developer/contributing/#contributing","text":"So, you've found an issue with bfg9000 or have an idea to improve it? Great! This page will provide you with some useful information to help you get started.","title":"Contributing"},{"location":"developer/contributing/#filing-an-issue","text":"Before contributing a patch, it's best to file an issue to discuss your plan. This will help ensure that you've got a good idea of the best way to go about things and don't go down the wrong path to start.","title":"Filing an issue"},{"location":"developer/contributing/#setting-up-a-development-environment","text":"Like most other Python-based projects, the easiest way to set up a development environment for bfg9000 is to use pip to install an editable version of the package. You'll probably also want all the testing dependencies, which you can install with the test extra: $ pip install -e '.[test]'","title":"Setting up a development environment"},{"location":"developer/contributing/#running-tests","text":"bfg9000 has a suite of tests to ensure that everything works properly. (Well, everything that has tests!) As you may expect, you can run these via: $ python setup.py test If you'd like to run a subset of tests, such as when trying to fix a bug in a specific area of the code, you can limit the tests that get run. For instance, to run only the tests in test/integration/test_simple.py , you can type: $ python setup.py test -s test.integration.test_simple To generate a coverage report, simply replace test with coverage , and build the report in the format you want, e.g.: $ python setup.py coverage && coverage html","title":"Running tests"},{"location":"developer/contributing/#linting-code","text":"bfg9000 uses flake8 for linting. You can check this with the lint command like so: $ python setup.py lint","title":"Linting code"},{"location":"developer/tools/","text":"Build Tools \u00a7 Note Build tools aren't currently extendable by third parties. However, this is planned . As a build configuration system, bfg9000 naturally interacts with many other tools; this interaction is defined for each tool in bfg9000/tools/ ; each file is automatically imported and the tools are added to a dict ultimately used by the environment object . Decorators \u00a7 @builder( lang , ...) \u00a7 Define a builder for one or more lang s. The API for builders is somewhat complex and currently beyond the scope of this document. @tool( name , [ lang ]) \u00a7 Define a tool named name that optionally acts as a runner for files with the language lang . The API for tools is somewhat complex and currently beyond the scope of this document. Accessors \u00a7 get_builder( env , lang ) \u00a7 Get the builder associated with lang , passing env (and lang if the builder was defined for multiple languages) to the builder type. get_tool( env , name ) \u00a7 Get the tool named name , passing env to the tool type. get_tool_runner( lang ) \u00a7 Get the name of the tool specified to run files with language lang .","title":"Build Tools"},{"location":"developer/tools/#build-tools","text":"Note Build tools aren't currently extendable by third parties. However, this is planned . As a build configuration system, bfg9000 naturally interacts with many other tools; this interaction is defined for each tool in bfg9000/tools/ ; each file is automatically imported and the tools are added to a dict ultimately used by the environment object .","title":"Build Tools"},{"location":"developer/tools/#decorators","text":"","title":"Decorators"},{"location":"developer/tools/#builderlang","text":"Define a builder for one or more lang s. The API for builders is somewhat complex and currently beyond the scope of this document.","title":"@builder(lang, ...)"},{"location":"developer/tools/#toolname-lang","text":"Define a tool named name that optionally acts as a runner for files with the language lang . The API for tools is somewhat complex and currently beyond the scope of this document.","title":"@tool(name, [lang])"},{"location":"developer/tools/#accessors","text":"","title":"Accessors"},{"location":"developer/tools/#get_builderenv-lang","text":"Get the builder associated with lang , passing env (and lang if the builder was defined for multiple languages) to the builder type.","title":"get_builder(env, lang)"},{"location":"developer/tools/#get_toolenv-name","text":"Get the tool named name , passing env to the tool type.","title":"get_tool(env, name)"},{"location":"developer/tools/#get_tool_runnerlang","text":"Get the name of the tool specified to run files with language lang .","title":"get_tool_runner(lang)"},{"location":"reference/builtins/","text":"Builtin Functions \u00a7 Below are listed all the builtin functions and properties available to bfg9000 scripts ( build.bfg and options.bfg ). Most are only available to build.bfg files, since that's where most of the build configuration logic belongs, but some may be used in options.bfg . Consult each function to see its availability. General \u00a7 Representing paths \u00a7 While all platforms have paths, their representation varies from platform to platform. bfg9000 smooths over these differences by providing a cross-platform representation of paths. Both POSIX- and Windows-style paths are supported and will be translated to a standard internal representation before being emitted to build scripts in their platform-specific form. Thus, foo/bar and foo\\bar are equivalent to bfg9000. In addition, you can terminate a path with / (or \\ ) to ensure that it's treated as a directory; this affects the behavior of some builtins, such as auto_file . Note While absolute paths are rarely needed in a build.bfg script, it's still possible to use them. However, there are some caveats: 1) on Windows, POSIX-style absolute paths will refer to that (absolute) path on the current drive, 2) Windows-style absolute paths will fail to work on POSIX systems, and 3) Windows-style paths with a drive letter and a relative path (e.g. C:foo ) are unsupported by bfg9000. File objects \u00a7 Files used in a build.bfg script are divided by their types (e.g. source code, header files, etc). All files from the source directory which are referenced in the build.bfg script will automatically be added to the source distribution when it's built. In most cases, you can simply pass a string to functions expecting a file object; the string will automatically be converted to a file object of the appropriate type. However, in some cases, you may wish to explicitly create a file object. This can be useful, for instance, when running commands that take a source file as an argument, e.g. in the following snippet: command('script', cmd=[source_file('script.py')]) Using source_file here allows you to specify that the file is a source code file found in the source directory , rather than the build directory. Further, since the file is a Python script, it can be executed as part of a command step. In addition to the functions listed in this section below, build steps which generate a file can also be used to produce source files of that type (see each step's documentation for details). Note By default, when creating a file object in the source directory, it will automatically be added to the project's source distribution . To disable this, you can specify dist=False when creating the file object. auto_file( name , [ lang ], *, [ dist ]) \u00a7 Create a reference to an existing file named name . This function will try to automatically determine the file's kind based on its extension: source_file ; header_file ; or, if the extension is not recognized, generic_file . If lang is specified, files with an unrecognized extension will always be treated as source_file s. If name ends with a / , auto_file will create a directory instead or, if lang is specified, a header_directory . Note This function is primarily useful for writing generic code that works with multiple kinds of files; when creating a reference to a specific, known file, the concrete function listed above should be used instead. directory( name , [ include ], *, [ extra ], [ exclude ], [ filter ], [ dist ], [ cache ]) \u00a7 Availability: build.bfg Create a reference to an existing directory named name ; if name is a file object, create a reference to the directory containing that file. The arguments include , extra , exclude , filter , dist , and cache are forwarded to find_files ; if neither include nor extra are specified, find_files will not be called. Any matching files will be added to the project's source distribution . extra_dist([ files ], [ dirs ]) \u00a7 Availability: build.bfg Add extra files and dirs to the list of recognized source files. This lets you reference files that are part of the source distribution but which have no impact on the build proper (e.g. READMEs). generic_file( name , *, [ dist ]) \u00a7 Availability: build.bfg Create a reference to an existing file named name . header_directory( name , [ include ], [ lang ], *, [ extra ], [ exclude ], [ filter ], [ system ], [ dist ], [ cache ]) \u00a7 Availability: build.bfg Create a reference to a directory named name containing header files for the project (if name is a file object, create a reference to the directory containing that file). This can then be used in the include argument when compiling a source file. The arguments include , extra , exclude , filter , dist , and cache are forwarded to find_files , as with directory . If system is True , this directory will be treated as a system directory for compilers that support this. header_file( name , [ lang ], *, [ dist ]) \u00a7 Availability: build.bfg Create a reference to an existing header named name . This is useful if you'd like to install a single header file for your project. If lang is not specified, the language of the file is inferred from its extension. man_page( name , *, [ level ], [ compress ], [ dist ], [ extra_deps ], [ description ]) \u00a7 Availability: build.bfg Create a reference to an existing man page named name at the specified level ; if level is unspecified, guess it by the first character of the extension of name . If compress is true, add a build step to gzip the man page and return the compressed file. If compress is 'auto' (the default), gzip the man page only if the gzip command is found on the system. module_def_file( name , *, [ dist ]) \u00a7 Availability: build.bfg Create a reference to an existing module-definition file named name . Module-definition files are sometimes used when building libraries on Windows. source_file( name , [ lang ], *, [ dist ]) \u00a7 Availability: build.bfg Create a reference to an existing source file named name . If lang is not specified, the language of the file is inferred from its extension. Build steps \u00a7 Build steps describe how to create a target output (usually a file) from zero or more inputs (usually files or other build steps). As you may expect, if the output is a file and it's either out of date or doesn't exist, the step is run to generate it. Each input is a dependency on the output, and any changes to an input will result in a rebuild. This includes headers #include d by any of the source files, but does not include files external to the project (i.e. packages ). Most build steps also have the ability to define additional dependencies via the extra_deps argument. These can be files or other build steps, and changes to them will trigger a rebuild as with the build's inputs. Further, many build steps also allow setting a custom description . This can be used to provide a friendlier message for the Ninja backend to show when building that step. File steps \u00a7 Naturally, the most common type of build step is one that generates a file. These are responsible for compiling object files, linking executables and libraries, and so on. In addition, all of these steps can be used like the file object functions described above to refer to prebuilt files already in the source tree (e.g. static libraries provided in binary form by a vendor). This is described in more detail for each step below. Note For file steps, the exact name of the output file is determined by the platform you're running on. For instance, when building an executable file named \"foo\" on Windows, the resulting file will be foo.exe . copy_file([ name ], file , *, [ mode ], [ directory ], [ extra_deps ], [ description ]) \u00a7 Availability: build.bfg Create a build step that copies a file named file to a destination named name ; if name is not specified, this function will use the filename in file as a base (this is primarily useful for copying a file from the source directory to the build directory). mode specifies how the file should be copied: 'copy' (the default), 'symlink' , or 'hardlink' . You can also specify directory as an optional subdirectory to place the copied file into if name is unspecified, as with object_file . This build step recognizes the environment variables for the relevant copy mode. copy_files( files , *, [ mode ], [ extra_deps ], [ description ]) \u00a7 Availability: build.bfg Create a build step to copy each of the files in files using the specified mode ; this is equivalent to calling copy_file for each element in files . Like object_files , copy_files returns a special list that allows you to index into it using the filename of one of the source files listed in files . executable( name , [ files , *, ..., [ extra_deps ], [ description ]]) \u00a7 Availability: build.bfg Create a build step that builds an executable file named name . files is the list of source (or object) files to link. If an element of files is a source file (or a plain string), this function will implicitly call object_file on it. The following arguments may also be specified: includes : Forwarded on to object_file pch : Forwarded on to object_file libs : A list of library files (see shared_library and static_library ) packages : A list of external packages ; also forwarded on to object_file compile_options : Forwarded on to object_file as options link_options : Command-line options to pass to the linker entry_point : The symbol for beginning execution of this program module_defs : A module_def_file specifying information about exports and other program info, sometimes used on Windows lang : Forwarded on to object_file intermediate_dir : Fowarded on to object_file as directory , defaulting to <name>.int extra_compile_deps : Forwarded on to object_file as extra_deps If neither files nor libs is specified, this function merely references an existing executable file (a precompiled binary, a shell script, etc) somewhere on the filesystem. In this case, name is the exact name of the file, relative to the source directory. This allows you to refer to existing executables for other functions. In addition, the following arguments may be specified: format : The object format of the exectuable; by default, this is the platform's native object format (e.g. 'elf' on Linux) This build step recognizes the dynamic linking environment variables and the compiler environment variable (e.g. CC ) for the relevant language. Note When passing options to the linker via link_options , these options will be passed to whatever executable is typically used to link object files for the source language; in particular, this means that when using a tool like GCC to build your project, any linker options that need to be forwarded on to ld should be prepended with '-Wl,' . generated_source([ name ], file , *, ..., [ extra_deps ], [ description ]) \u00a7 Availability: build.bfg Create a build step that generates a source file named name from an input (typically another source file) named file ; if name is not specified, this function will use the filename in file as a base (typically the filename with a different extension). Note that unlike with other file steps, name represents the exact file name to be used for the output file (i.e. the file extension isn't added automatically). The following arguments may also be specified: options : Command-line options to pass to the compiler lang : The language of the source file; useful if the source file's extension isn't recognized by bfg9000 directory : An optional subdirectory to place the source file into if name is unspecified Note When building files via yacc , this step will automatically generate both source and header files named <name>.tab.c and <name>.tab.h . You can force this step to build only the source file by passing a single filename to the name argument; you can also customize the names by passing a pair of filenames: generated_source(['foo.c', 'foo.h'], 'bar.y') This build step recognizes the compilation environment variables for the relevant language. generated_sources( files , *, ..., [ extra_deps ], [ description ]) \u00a7 Availability: build.bfg Create a source-generation build step for each of the files in files ; this is equivalent to calling generated_source for each element in files . Like object_files , generated_sources returns a special list that allows you to index into it using the filename of one of the source files listed in files . library( name , [ files , *, ..., [ extra_deps ], [ description ]]) \u00a7 Availability: build.bfg Create a build step that builds a shared library named name . Its arguments are the same as the superset of shared_library and static_library , with the following additional argument: kind : The kind of library to be built; one of 'shared' , 'static' , or 'dual' (to build both shared and static versions). If not specified, the default behavior depends on the command-line arguments passed to bfg9000. To enable/disable shared libraries, pass --enable-shared / --disable-shared , and for static libraries, pass --enable-static / --disable-static . Like with executable , if files isn't specified, this function merely references an existing library somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. You may also pass in the format argument as with executable . If name refers to a dual-use library, this function will return the library subtype as specified in kind (e.g. passing 'shared' will return the shared version of the library). This build step recognizes the dynamic linking environment variables or the static linking environment variables , as well as the compiler environment variable (e.g. $CC ) for the relevant language. Warning By convention, MSVC uses the same filenames for static libraries as for import libs for shared libraries. As a result, if both shared and static library builds are enabled with MSVC, bfg9000 will fall back to building only the shared library. object_file([ name ], [ file , *, ..., [ extra_deps ], [ description ]]) \u00a7 Availability: build.bfg Create a build step that compiles a source file named file to an object file named name ; if name is not specified, this function will use the filename in file as a base (typically the filename without the extension). The following arguments may also be specified: includes : A list of directories to search for header files; you may also pass header files , and their directories will be added to the search list pch : A precompiled header to use during compilation libs : A list of library files (see shared_library and static_library ); this is only used by languages that need libraries defined at compile-time, such as Java packages : A list of external packages options : Command-line options to pass to the compiler lang : The language of the source file; useful if the source file's extension isn't recognized by bfg9000 directory : An optional subdirectory to place the object file into if name is unspecified (this is used by executable and friends to place implicitly-defined object files in an intermediate directory) If file isn't specified, this function merely references an existing object file somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. In addition, the following arguments may be specified: format : The object format of the file; by default, this is the platform's native object format (e.g. 'elf' on Linux) lang : The source language of the file; if none is specified, defaults to 'c' This build step recognizes the compilation environment variables for the relevant language. object_files( files , *, ..., [ extra_deps ], [ description ]) \u00a7 Availability: build.bfg Create a compilation build step for each of the files in files ; this is equivalent to calling object_file for each element in files . In addition, object_files returns a special list that allows you to index into it using the filename of one of the source files listed in files . This makes it easy to extract a single object file to use in other places, e.g. test code. For example: objs = object_files(['foo.cpp', 'bar.cpp']) release_exe = executable('release', objs) foo_obj = objs['foo.cpp'] test_exe = executable('test', ['test.cpp', foo_obj]) precompiled_header([ name ], [ file , *, ..., [ extra_deps ], [ description ]]) \u00a7 Availability: build.bfg Create a build step that generates a precompiled header, which can be used to speed up the compilation of object files . If name is not specified, it is inferred from the value of file ; the exact name varies based on the compiler being used, but typically looks like header.hpp.pch for cc-like compilers and header.pch for MSVC-like compilers. The arguments for precompiled_header are the same as for object_file , with the following additional argument: pch_source : The source file to be used when building the precompiled header. If this is not specified, a source file will automatically be created, containing nothing but #include \"header\" , where header is the name of the header specified in file . This option only applies to MSVC-like compilers; for all others, it is ignored. If file isn't specified, this function merely references an existing precompiled header somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. In addition, the following argument may be specified: lang : The source language of the file; if none is specified, defaults to 'c' Warning The exact behavior of precompiled headers varies according to the compiler you're using. In GCC and Clang , the header to be precompiled must be the first file #include d in each source file. In MSVC , the resulting precompiled header is actually compiled within the context of a particular source file and will contain all the code up to and including the header in question. shared_library( name , [ files , *, ..., [ extra_deps ], [ description ]]) \u00a7 Availability: build.bfg Create a build step that builds a shared library named name . Its arguments are the same as executable , with the following additional arguments: version : The version number of the library, e.g. 1.2.3 . soversion : The API version of the library (used in its soname), e.g. 1 . Like with executable , if files isn't specified, this function merely references an existing shared library somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. You may also pass in the format argument as with executable . If name refers to a dual-use library, this function will return the shared version of the library. This build step recognizes the dynamic linking environment variables and the compiler environment variable (e.g. CC ) for the relevant language. Note On Windows, this produces two files for native-runtime languages (e.g. C or C++): name.dll and name.lib . The latter is the import library , used when linking to this library. Additionally for native languages on Windows, this step will add a preprocessor macro named LIB<NAME>_EXPORTS that can be used for declaring public symbols. See Building libraries on Windows for an example of how to use this macro in your code. static_library( name , [ files , *, ..., [ extra_deps ], [ description ]]) \u00a7 Availability: build.bfg Create a build step that builds a static library named name . Its arguments are the same as executable (however, entry_point cannot be specified for static libraries), with the following additional argument: static_link_options : Command-line options to pass to the linker Other link-related arguments ( link_options , libs , and libraries from packages ) have no direct effect on this build step. Instead, they're cached and forwarded on to any dynamic linking step that uses this static library. Like with executable , if files isn't specified, this function merely references an existing shared library somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. In addition, the following arguments may be specified: format : The object format of the exectuable; by default, this is the platform's native object format (e.g. 'elf' on Linux) lang : The source language(s) of the library; if none is specified, defaults to ['c'] If name refers to a dual-use library, this function will return the static version of the library. This build step recognizes the static linking environment variables . Note On Windows, this step will add a preprocessor macro on Windows named LIB<NAME>_STATIC that can be used for declaring public symbols. See Building libraries on Windows for an example of how to use this macro in your code. whole_archive( name , [ files , *, ..., [ extra_deps ]]) \u00a7 Availability: build.bfg Create a build step that builds a whole-archive named name . Whole archives ensures that every object file in the library is included, rather than just the ones whose symbols are referenced. This is typically used to turn a static library into a shared library. whole_archive 's arguments are the same as for static_library . In addition, you can pass an existing static library to whole_archive to convert it into a whole archive. Test steps \u00a7 These steps help you define automated tests that can all be run via the test target. For simple cases, you should only need the test function, but you can also wrap your tests with a separate driver using test_driver . For cases where you only want to build the tests, not run them, you can use the tests target. test( test , *, [ environment | driver ]) \u00a7 Availability: build.bfg Create a single test. cmd is the base command (possibly with arguments) to run; this works much like the cmd argument in the command built-in. You can also pass temporary environment variables as a dict via environment , or specify a test driver to add this test file to via driver . test_driver( cmd , *, [ environment | parent ], [ wrap_children ]) \u00a7 Availability: build.bfg Create a test driver which can run a series of tests, specified as command-line arguments to the driver. cmd is the base command (possibly with arguments) to run; this works much like the cmd argument in the command built-in. You can also pass temporary environment variables as a dict with environment , or specify a parent test driver to wrap this driver via parent . Finally, you can specify wrap_children to determine how tests using this driver are run. If true, each test will be wrapped by env.run_arguments ; if false (the default), tests will be used as-is. test_deps( ... ) \u00a7 Availability: build.bfg Specify a list of extra dependencies which must be satisfied when building the tests via the tests target. Grouping steps \u00a7 alias( name , [ deps ]) \u00a7 Availability: build.bfg Create a build step named name that performs no actions on its own. Instead, it just runs its dependencies listed in deps as necessary. This build step is useful for grouping common steps together. default( ... ) \u00a7 Availability: build.bfg Specify a list of build outputs that should be run by default when building. These are all accumulated into the all target. If an iterable object is passed as an argument to default , each element of the iterable will be added. If default is never called, all executables and libraries not passed to test will be built by default. To allow this to be chained with other functions, default will return the arguments passed into it: as a single object if one argument is passed, or a tuple if multiple are passed. install( ... , [ directory ]) \u00a7 Availability: build.bfg Specify a list of files that need to be installed for the project to work. Each will be installed to the appropriate location based on its type, e.g. header files will go in $PREFIX/include by default on POSIX systems. These are all accumulated into the install target. If an iterable object is passed as an argument to install , each element of the iterable will be added. If there are any runtime dependencies for a file (such as shared libraries you just built), they will be installed as well. The install location can be customized via the directory argument. If passed as a string, the value will be appended to the default install location, e.g. install(header_file('foo.hpp'), directory='dir') will install to $INCLUDEDIR/dir/foo.hpp . You can also pass a Path object to override the default install location entirely. To allow referencing the installed copies of the files passed to it, install will return file objects representing the installed files: as a single object if one argument is passed, or a tuple if multiple are passed. Note When explicitly listing a target, all the files for that target will be installed. For instance, on Windows, this means that passing in a shared library will install the DLL and the import library. This step recognizes the following environment variables: $DESTDIR , $INSTALL , $INSTALL_NAME_TOOL , $MKDIR_P , $PATCHELF . User-defined steps \u00a7 While the standard build steps cover the most common tasks in a build, many projects need to run more-specialized commands. A build script can define custom steps via the build_step and command functions: build_step defines a step which outputs one or more files that can be used in other steps, while command defines a more general step that should always be run when it's a target (similar to the test or install targets). Both build_step and command allow you to specify an arbitrary command cmd or cmds ; cmd takes a single command, whereas cmds takes a list of commands. Each command will be passed through env.run_arguments() and may be a string (to be parsed according to shell rules), a file object (such as an executable ), or a list of arguments to be passed directly to the process. Any file objects specified in the command will automatically be added as dependencies to this step. In addition, commands can include placeholders , which will automatically be expanded to the files corresponding to that placeholder. You may also pass a dict to environment to set environment variables for the commands. These override any environment variables set on the command line. build_step( name , *, cmd | cmds , [ files ], [ environment ], [ type ], [ always_outdated ], [ extra_deps ], [ description ]) \u00a7 Availability: build.bfg Create a custom build step that produces one or more files named name by running an arbitrary command ( cmd or cmds ). name may either be a single file name or a list of file names. If always_outdated is true, this build step will be considered out-of-date no matter the status of the output. The command argument can use the placeholders build_step.output to refer to the output files (defined by name ) and build_step.input to refer to the input files (defined by files ). By default, the output of this step is one or more auto_file s; you can adjust this with the type argument: this should be a function (or a list thereof) taking a path and returning a file object. If type is a single function, it will be applied to every output of build_step ; if it's a list of functions, they will be applied element-wise to each output. command( name , *, cmd | cmds , [ files ], [ environment ], [ extra_deps ], [ description ]) \u00a7 Availability: build.bfg Create a build step named name that runs an arbitrary command, specified in either cmd or cmds . This build step is always considered out-of-date (as with a \"phony\" Makefile target, such as test or install ). The command argument can use the placeholder command.input to refer to the input files (defined by files ). placeholder \u00a7 Availability: build.bfg When used in the cmd or cmds argument of build_step or command , this will create a reference to the inputs or outputs of the step. Placeholders can be indexed or sliced just like ordinary Python lists, and can also be combined with strings to add prefixes and suffixes: script = source_file('script.py') # Roughly equivalent to `python script.py -ifoo.txt -sbar.txt -squux.txt` command('foo', cmd=[ script, '-i' + command.input[0], '-s' + command.input[1:] ], files=['foo.txt', 'bar.txt', 'quux.txt']) Semantic options \u00a7 Semantic options are a collection of objects that allow a build to define options in a tool-agnostic way. These options will automatically be converted to the appropriate string form for the tool when generating the build file. opts.debug() \u00a7 Produce debugging information for the built object in the default debugging format. When using MSVC, this also determines whether to link to debug or release variants of the runtime. opts.define( name , [ value ]) \u00a7 Create a preprocessor macro named name and with an optional value value . Note that if you'd like the value to be a string literal, you need to escape the string like so: opts.define('MY_MACRO', '\"This is a string, isn\\'t it?\"') opts.entry_point( value ) \u00a7 Set the symbol to use for beginning program execution. This is equivalent to passing entry_point=value to executable or shared_library . opts.gui([ main ]) \u00a7 Generate a graphical program; this is important for Windows builds, since the default is to generate a command-line program that opens a terminal window. On Windows, this option sets the subsystem to WINDOWS ; if main is true, it also sets the entry point to mainCRTStartup (which calls the standard main function instead of the Windows-specific WinMain ). On other platforms, this option has no effect. opts.optimize( ... ) \u00a7 Set the level of optimization for the compiler employ; multiple values can be specified at once, e.g. opts.optimize('speed, 'linktime) . The possible warning values are: 'disable' : Disable all optimization 'size' : Enable optimization to minimize the size of the resulting binary 'speed' : Enable optimization to maximize the speed of the resulting binary 'linktime' : Perform link-time optimizations opts.sanitize() \u00a7 Enable run-time sanitization checks when compiling a particular source file; this is equivalent to -fsanitize=address on GCC-like compilers and /RTC1 on MSVC. opts.static() \u00a7 When linking to libraries, only link statically. opts.std( value ) \u00a7 Specify the version of the language's standard (e.g. \"c++14\" ) to use when building. opts.warning( ... ) \u00a7 Set the level of warnings for the compiler to emit when compiling; multiple values can be specified at once, e.g. opts.warning('all', 'error') . The possible warning values are: 'disable' : Disable all warning messages 'all' : Enable all \"recommended\" warnings (as GCC puts it, \"the warnings about constructions that some users consider questionable, and that are easy to avoid\") 'extra' : Enable extra warnings in addition to what's specified in 'all' 'error' : Treat any warning as an error Global options \u00a7 global_options( options , lang ) \u00a7 Availability: build.bfg Specify some options (either as a string or list) to use for all compilation steps for the language (or list of languages) lang . global_link_options( options , [ family ], [ mode ]) \u00a7 Availability: build.bfg Specify some options (either as a string or list) to use for all link steps for a given family of languages (or a list of families) and linking mode . By default family is 'native' , used for C, C++, and other languages using the same linking process. You can also specify 'jvm' for JVM-based languages (Java, Scala). mode may be either 'dynamic' (the default) to modify executables and shared libraries or 'static' to modify static libraries . Note As with the link_options argument for executable() and shared_library() , dynamic link options will be passed to whatever executable is typically used to link object files for the source language; in particular, this means that when using a tool like GCC to build your project, any linker options that need to be forwarded on to ld should be prepended with '-Wl,' . Package resolvers \u00a7 framework( name , [ suffix ]) \u00a7 Reference a macOS framework named name with the optional suffix suffix . Though not a \"package\" in name, this can be used wherever packages are accepted. package( name , [ submodules ], [ version ], *, [ lang ], [ kind ], [ system ]) \u00a7 Availability: build.bfg Search for a package named name optionally containing one or more submodules . lang is the source language of the package (if not specified, this will use the default language for the project); this will affect how the package is resolved. For native packages (C, C++, Fortran, etc), this will use mopack to resolve the package; otherwise, this will use a language-specific check to find packages on the system. If this function is unable to find the package, it will raise a PackageResolutionError . You can also specify kind to one of 'any' (the default), 'shared' , or 'static' . This allows you to restrict the search to find only static versions of a library, for example. If system is True (the default), any directories will be treated as system directories for compilers that support this. If version is specified, it will (if possible) ensure that the installed version of the package meets the version requirement; it must be formatted as a Python version specifier . If this check fails, a PackageVersionError will be raised. When calling this function, you can exclude the submodules argument and pass a version as the second positional argument if it's parseable as a version specifier. For example, package('pkg', '>=1.0') . This function recognizes the following environment variables: $CLASSPATH , $CPATH , $INCLUDE , $LIB , $LIBRARY_PATH , $PKG_CONFIG . Note This function can also be used to refer to the pthread library. On many Unix-like systems, instead of using -lpthread during the link step, it's preferred to use -pthread during compilation and linking. Using package('pthread') will handle this automatically. pkg_config([ name ], *, [ version ], [ includes ], [ libs ], [ auto_fill ], ... ) \u00a7 Availability: build.bfg Create pkg-config information for this project and install it along with the rest of the installed files. In addition, create an -uninstalled variant of the pkg-config file to allow it to be used prior to installing the project. All of the arguments below are optional and will be automatically inferred from the rest of the build where possible. Unless otherwise noted, these arguments correspond directly to the fields in the pkg-config .pc file. name : The name of the package (to be used as the name of the .pc file) desc_name : A human-readable name for the package (stored as the Name field in pkg-config); defaults to name desc : A brief description of the package; defaults to <name> library url : A URL where users can learn more about the package version : The package's version requires : A list of packages required by this package; these can be strings, a string and version specifier, or the results from package . In the last case, packages resolved by pkg-config are added directly as requirements; those resolved by other means are added to the Libs field in pkg-config requires_private : A list of packages required by this package but not exposed to users; these can be specified as with requires conflicts : A list of packages that conflict with this package; these can be specified as with requires includes : A list of directories (or header files ) to add to the search path for users of this package libs : A list of libraries for users of this package to link to; any dependent libraries, packages, or link options (in the case of static libs) will automatically be added to libs_private , requires_private , and link_options_private , respectively libs_private : A list of libraries required by this package but not exposed to users (this is used primarily for static linking); dependent libraries, packages, and link options are added as with libs options : A list of compile options for this package link_options : A list of link options for this package link_options_private : A list of link options for this package but not exposed to users (this is used primarily for static linking) lang : The language of the builder to use when generating option strings; by default, 'c' system : If True , any include directories will be treated as system directories when using the package internally (for compilers that support this); defaults to False . If auto_fill is true, this function will automatically fill in default values for the following fields: name : The project's name (this also fills in desc_name and desc with default values) version : The project's version , or 0.0 if none is specified includes : The list of installed header files/directories libs : The list of installed library files If auto_fill is false, this function will return a package object that can be used in other build steps as normal. system_executable( name , [ format ]) \u00a7 Availability: build.bfg Search for an executable named name somewhere in the system's $PATH . If format is unset, the executable's object format will be set to the default for the host platform. This function recognizes the following environment variables: $PATH , $PATHEXT . Environment \u00a7 Occasionally, build scripts need to directly query aspects of the environment. In bfg9000, this is performed with the environment object and its various members. Environment object \u00a7 The environment , env , is a special object that encapsulates information about the system outside of bfg9000. It's used internally for nearly all platform-specific code, but it can also help in build.bfg (or options.bfg !) files when you encounter some unavoidable issue with multiplatform compatibility. Note This listing doesn't cover all available functions on the environment, since many are only useful to internal code. However, the most relevant ones for build.bfg files are shown below. env.builder( lang ) \u00a7 Return the builder used by bfg9000 for a particular language lang . env.execute( args , *, [ env ], [ extra_env ], [ shell ], [ stdout ], [ stderr ], [ returncode ]) \u00a7 Execute the command-line arguments in args and return the output. If shell is true, args should be a string that will be interpreted by the system's shell; if not (the default), it should be a series of arguments. You can also set env to be a dictionary of environment variables to pass to the child process; if env is None (the default), the environment variables in env.variables will be used instead. Similarly, you can set extra_env to be a dict of env vars; these will be added to the dict in env (or to env.variables if env is None ) to produce the final set of environment variables to pass to the child process. stdout and stderr are env.Mode values that describe how (or if) output should be redirected. By default, both are set to Mode.normal . Finally, returncode specifies the expected return code from the subprocess. This is 0 by default, and may be either a number, a list of numbers, or 'any' to match any return code. If the return code fails to match, a CalledProcessError will be thrown. env.getvar( name , [ default ]) \u00a7 Equivalent to env.variables .get(name, default) . env.host_platform \u00a7 Return the host platform used for the build. env.Mode \u00a7 An enumeration of output modes for env.execute and env.run . Possible values are: normal : Perform no redirection and output to stdout/stderr normally pipe : Pipe the output and return it to the calling process stdout : Pipe stderr output to stdout devnull : Pipe output to /dev/null or equivalent env.run_arguments( args , [ lang ]) \u00a7 Generate the arguments needed to run the command in args . If args is a file type (or a list beginning with a file type) such as an executable , it will be prepended with the runner for lang as needed. If lang is None , the language will be determined by the language of args 's first element. env.run( args , *, [ lang ], [ env ], [ extra_env ], [ stdout ], [ stderr ], [ returncode ]) \u00a7 Run a command, generating any arguments needed to perform the operation. Equivalent to env.execute(env.run_arguments(arg, lang), ...) . env.target_platform \u00a7 Return the target platform used for the build. env.tool( name ) \u00a7 Return the tool named name . env.variables \u00a7 A dict of all the environment variables as they were defined when the build was first configured. Builders \u00a7 Builder objects represent the toolset used to build executables and libraries for a particular source language. They can be retrieved via env.builder . While builder objects are primarily suited to bfg's internals, there are still a few useful properties for build.bfg files: builder .flavor \u00a7 The \"flavor\" of the builder, i.e. the kind of command-line interface it has. Possible values are 'cc' , 'msvc' , and 'jvm' . builder .brand \u00a7 The brand of the builder, i.e. the command name people use for it. Currently, for languages in the C family (including Fortran), this is one of 'gcc' , 'clang' , 'msvc' , or 'unknown' . For languages in the Java family, this is one of 'oracle' , 'openjdk' , 'epfl' (for Scala), or 'unknown' . builder .version \u00a7 The version of the builder (specifically, the version of the primary compiler for the builder). May be None if bfg9000 was unable to detect the version. builder .lang \u00a7 The language of the source files that this builder is designed for. builder .object_format \u00a7 The object format that the builder outputs, e.g. 'elf' , 'coff' , or 'jvm' . builder .compiler \u00a7 The compiler used with this builder. builder .pch_compiler \u00a7 The compiler used to build precompiled headers with this builder. May be None for languages or toolsets that don't support precompiled headers. builder .linker( mode ) \u00a7 The linker used with this builder. mode is one of 'executable' , 'shared_library' , or 'static_library' Its public properties are the same as compiler . cc -like builders also support a mode of 'raw' , which returns an object representing the actual linker, such as ld . builder .runner \u00a7 The runner used with files built by this builder (e.g. java ). This may be None for languages which have no runner, such as C and C++. Compilers/linkers \u00a7 Compiler and linker objects represent the specific tool used to compile a source file (generally into an object file ) or to link a set of object files (generally into an executable or library ). compiler .flavor \u00a7 The \"flavor\" of the compiler, i.e. the kind of command-line interface it has; e.g. 'cc' , 'msvc' . compiler .brand \u00a7 The brand of the compiler; typically the same as builder.brand . compiler .version \u00a7 The version of the compiler; typically the same as builder.version . compiler .language \u00a7 The language of the compiler; typically the same as builder.language . compiler .command \u00a7 The command to run when invoking this compiler, represented as a list, e.g. ['g++'] . compiler .found \u00a7 Whether the command for this compiler was found on the system. Tools \u00a7 Tool objects represent a specific command used to perform some task (usually during a build), such as 'copy' or 'rm' . They can be retrieved via env.tool . While tool objects are primarily suited to bfg's internals, there are still a few useful properties for build.bfg files: tool .command \u00a7 The command to run when invoking this tool, represented as a list, e.g. ['cp', '-f'] . tool .found \u00a7 Whether this tool was found on the system. Platforms \u00a7 Platform objects represent the platform that the project is being compiled for. platform .family \u00a7 The family of the platform. Either 'posix' or 'windows' . platform .genus \u00a7 The sub-type of the platform, e.g. 'linux' , darwin' , or 'winnt' . platform .name \u00a7 An alias for platform.species . platform .species \u00a7 The specific name of the platform, e.g. 'linux' , 'macos' , or 'winnt' . Utilities \u00a7 argument( names ..., [ action ], [ nargs ], [ const ], [ default ], [ type ], [ choices ], [ required ], [ help ], [ metavar ], [ dest ]) \u00a7 Availability: options.bfg Define how a particular command-line argument will be parsed. names is a sequence of argument names; these will be prefixed with -- and --x- for parsing. For example, passing 'foo' will add --foo and --x-foo as possible command-line arguments. All other arguments to this function have the same behavior as in argparse.ArgumentParser.add_argument() , with the exception of action , which accepts two extra values: 'enable' : Add a pair of arguments of the form --enable-<name> and --disable-<name> (with --x- -prefixed versions as well), storing True if --enable-<name> is specified and False if --disable-<name> is. 'with' : As 'enable' , except the arguments are of the form --with-<name> and --without-name . argv \u00a7 Availability: build.bfg Retrieve the set of user-defined arguments passed to bfg9000; this is an argparse.Namespace object. __bfg9000__ \u00a7 Availability: build.bfg , options.bfg , and <toolchain>.bfg A dictionary containing all the builtin functions and global variables defined by bfg9000. This can be useful for feature detection or accessing builtins shadowed by a local variable. bfg9000_required_version([ version ], [ python_version ]) \u00a7 Availability: build.bfg , options.bfg , and <toolchain>.bfg Set the required version for bfg9000 and/or the required python_version . Each of these is a standard Python version specifier . If the actual versions don't match the specifiers, a VersionError is raised. bfg9000_version \u00a7 Availability: build.bfg , options.bfg , and <toolchain>.bfg Return the current version of bfg9000. This can be useful if you want to optionally support a feature only available in certain versions of bfg. debug( ... , [ show_stack ]) \u00a7 Availability: build.bfg , options.bfg , and <toolchain>.bfg Log a debug message with the specified arguments separated by spaces (as with print() ). If show_stack is true (the default), show the stack trace where the message was logged from. Note Debug messages are hidden by default; pass --debug on the command line to them. export( ... ) \u00a7 Availability: build.bfg and options.bfg Within a submodule , export a list of keyword arguments to be returned to the calling module. filter_by_platform( path ) \u00a7 Availability: build.bfg Return FindResult.include if path is a filename that should be included for the target platform, and FindResult.not_now otherwise. File (or directory) names like PLATFORM or foo_PLATFORM.cpp are excluded if PLATFORM is a known platform name that doesn't match the target platform. Known platform names are: 'posix' , 'linux' , 'darwin' , 'cygwin' , 'windows' , 'winnt' , 'win9x' , 'msdos' . This can be used as the filter for find_files or find_path . FindResult \u00a7 Availability: build.bfg An enum to be used as the result of a filter function for find_files . The possible enum values are: include : Include this file in the results not_now : Don't include this file in the results, but do include it in the source distribution exclude : Don't include this file in the results exclude_recursive : Don't include this directory or any of its contents in the results find_files([ pattern ], *, [ type ], [ extra ], [ exclude ], ... ) \u00a7 Availability: build.bfg Find files that match the glob (or list of globs) pattern , returning them as file objects . Globs work much the same as in POSIX shells, with support for the following patterns: * : 0 or more of any character ? : 1 of any character [abc] : any one character in abc [!abc] : any one character not in abc ** : 0 or more path components (subdirectories, files) By default, globs that end with a / will match only directories, while globs not ending with / will match only files. In addition, globs may be passed as path objects , allowing you to specify a different root to find files in (e.g. the build directory). \"Simple\" globs, used for extra and exclude (see below) support all of the above except for ** , and are matched against only the basename of each file. By default, several globs ( .#* , *~ , and #*# ) are excluded; this can be customized via the find_exclude argument to project . The following arguments may also be specified: type : A filter for the type of file: 'f' to find only files, 'd' to find only directories, or '*' to find either; if not specified, the type will be inferred by the glob itself, as described above extra : A simple glob (or list thereof) to match \"extra\" files; these will not be returned from find_files but will be added to the source distribution ) exclude : A simple glob (or list thereof) of files to exclude from results; if a directory is matched, it and all of its children will be excluded filter : A predicate taking a Path object and returning a FindResult which will filter the results file_type : The type of object to return for matching files; if specified, this should be a function taking a path object and a boolean (the dist argument below), otherwise an auto_file will be returned dir_type : The type of object to return for matching directories, as with file_type ; the default type is a directory dist : If true (the default), all files found by this function will automatically be added to the source distribution cache : If true (the default), cache the results so that any changes to will regenerate the build scripts for the project The cache argument is particularly important. It allows you to add or remove source files and not have to worry about manually rerunning bfg9000. find_paths([ pattern ], *, [ type ], [ extra ], [ exclude ], ... ) \u00a7 Availability: build.bfg Find files that match the glob (or list of globs) pattern , returning them as path objects . The arguments to this function are the same as for find_files . info( message , [ show_stack ]) \u00a7 Availability: build.bfg , options.bfg , and <toolchain>.bfg Log an informational message with the specified arguments separated by spaces (as with print() ). If show_stack is true, show the stack trace where the message was logged from. InstallRoot \u00a7 Availability: build.bfg , options.bfg , and <toolchain>.bfg An enumeration of root directories for Path objects, to be used during installation. Possible values are: prefix : A path relative to the prefix where the build will be installed exec_prefix : A path relative to the prefix where executable code (binaries and libraries) will be installed bindir : A path relative to where binaries will be installed libdir : A path relative to where libraries will be installed includedir : A path relative to where header files will be installed datadir : A path relative to where data files will be installed mandir : A path relative to where man pages will be installed Path( path , [ root ], [ destdir ]) \u00a7 Availability: build.bfg , options.bfg , and <toolchain>.bfg Create a new path object for a given path . root may be a value in the Root or InstallRoot enumerations, or another Path object. When the root is a value in InstallRoot , you can also specify destdir ; if true, this path will be prepended with $DESTDIR on platforms that support destdirs. When the root is another path, this constructor will return the same value as root.append(path) . Path .addext( ext ) \u00a7 Append the extension ext to this path and return the new path. Note that ext should include the leading dot, e.g. '.txt' . Path .append( path ) \u00a7 Append a new path component to this path and return the result. Path .basename() \u00a7 Return the basename (the last path component) of this path. Path .ext() \u00a7 Return the extension of this path, if any; otherwise, return '' . Path .parent() \u00a7 Return the parent of this path as a new Path object. Path .relpath( start , [ prefix ], [ localize ]) \u00a7 Return a string representing this path's location relative to a starting path start . Both paths should have the same Root . If localize is true (the default), this function will translate the path to the native form for the host platform; otherwise, it will return it untranslated (using POSIX-style separators). Path .reroot( root ) \u00a7 Return a new Path object with the same path suffix as this path, but with the path root set to root . Path .root \u00a7 Return the Root of this path. Path .split() \u00a7 Split this path's suffix into a list of its components. Path .splitleaf() \u00a7 Split the leaf component of this path and return the parent and leaf. Equivalent to (path.parent(), path.basename()) . Path .suffix \u00a7 Return the suffix of this path (the portion that would be appended to the path's root . Path .stripext([ replace ]) \u00a7 Remove the extension from this path and replace it with an optional new extension specified in replace , returning the newly-created Path object. path_exists( name ) \u00a7 Return whether the path named name exists on the filesystem. name can be either a string or a path object . project([ name ], [ version ], ...) \u00a7 Availability: build.bfg Set the name and/or version of the project. If you don't call this function to specify a project name, it defaults to the name of the project's source directory. This is primarily useful for creating source distributions . In addition, you can set a number of project-wide options with this function: intermediate_dirs : (Default True ) Automatically place implicitly-generated intermediate files into separate directories lang : (Default 'c' ) The default language to use for objects that can't infer their language from a file extension (e.g. packages , object files , libraries ) find_exclude : (Default ['.*#', '*~', '#*#'] ) A list of \"simple\" globs to exclude by default when calling find_files or find_paths Root \u00a7 Availability: build.bfg , options.bfg , and <toolchain>.bfg An enumeration of root directories for Path objects. Possible values are: srcdir : A path relative to the project's source directory builddir : A path relative to the build directory absolute : An absolute path safe_format( fmt , ...) \u00a7 Availability: build.bfg , options.bfg , and <toolchain>.bfg Safely format a string fmt , as with str.format . Unlike str.format however, this converts placeholders to string via safe_str , ensuring that the result is correctly-escaped when used in a build script. safe_str( s ) \u00a7 Availability: build.bfg , options.bfg , and <toolchain>.bfg Convert an object s into a \"safe\" string, if possible. Safe strings are used by the build backends to correctly handle escaping special characters as needed. submodule( path ) \u00a7 Availability: build.bfg and options.bfg Include and execute the build.bfg (or options.bfg , as appropriate) file contained in the submodule path . Within the submodule's bfg file, all paths for inputs (source files) and outputs (built files) are evaluated relative to path . This function returns a dict of all the exported objects from the submodule's bfg file. warning( ... ) \u00a7 Availability: build.bfg , options.bfg , and <toolchain>.bfg Log a warning with the specified arguments separated by spaces (as with print() ) and the stack trace where the warning was emitted. Toolchain \u00a7 compiler( names , lang ) \u00a7 Availability: <toolchain>.bfg Set the compiler to use for the language lang . names is a string representing the path to the compiler (resolved as with which ) or a list of possible paths (as strings or lists or strings). If strict is true, compiler will raise an IOError if an executable cannot be found; if false, it will use the first candidate. compile_options( options , lang ) \u00a7 Availability: <toolchain>.bfg Set compilation options to use for the language lang . options is either a string of all the options or a list of strings, one element per option. Note Semantic options aren't supported here; instead, you should use the appropriate option strings for the compiler to be used. environ \u00a7 Availability: <toolchain>.bfg A dict of the current environment variables, suitable for getting/setting. install_dirs([...]) \u00a7 Availability: <toolchain>.bfg Set the installation directories for this toolchain. Arguments to this function should be keyword args with one of the following names: prefix , exec_prefix , bindir , libdir , or includedir . Note Any installation directory set here overrides directories set on the command line. lib_options( options , [ format ], [ mode ]) \u00a7 Availability: <toolchain>.bfg Set lib options to use for the format format (defaults to 'native' ) and mode mode (defaults to 'dynamic' ). options is either a string of all the options or a list of strings, one element per option. Unlike link_options , this is used to specify options which appear at the end of a linker command (like $LDLIBS ). linker( names , [ format ], [ mode ]) \u00a7 Availability: <toolchain>.bfg Set the link to use for the format format (defaults to 'native' ) and mode mode (defaults to 'dynamic' ). names is a string representing the path to the linker (resolved as with which ) or a list of possible paths (as strings or lists or strings). If strict is true, linker will raise an IOError if an executable cannot be found; if false, it will use the first candidate. link_options( options , [ format ], [ mode ]) \u00a7 Availability: <toolchain>.bfg Set link options to use for the format format (defaults to 'native' ) and mode mode (defaults to 'dynamic' ). options is either a string of all the options or a list of strings, one element per option. runner( names , lang ) \u00a7 Availability: <toolchain>.bfg Set the runner to use for the language lang , if that language supports runners (e.g. Java, Scala, or a scripting language). names is a string representing the path to the compiler (resolved as with which ) or a list of possible paths (as strings or lists or strings). If strict is true, compiler will raise an IOError if an executable cannot be found; if false, it will use the first candidate. srcdir \u00a7 Availability: <toolchain>.bfg Return the source directory of this project as a Path object. target_platform([ platform ], [ arch ]) \u00a7 Availability: <toolchain>.bfg Set the target platform of this build to platform and the architecture to arch . If either is not specified, the host system's platform/arch will be used. The following platforms are recognized: 'android' , 'cygwin' , 'ios' , 'linux' , 'macos' , 'win9x' , and 'winnt' . Other platforms (e.g. 'freebsd' ) can be specified, and will be treated as generic POSIX platforms. which( names , [ resolve ], [ strict ]) \u00a7 Availability: <toolchain>.bfg Find the best option for an executable named by names . names can be a string resolved as with the $PATH environment variable in the shell, or else a list of names (as strings or lists of strings). If names contains a list-of-lists, the inner list represents a series of arguments to pass to the executable when running it. If strict is true (the default), which will raise an IOError if an executable cannot be found; if false, it will return the first candidate as a string. Exceptions \u00a7 CalledProcessError \u00a7 Availability: build.bfg and options.bfg An exception raised when a subprocess fails to execute successfully. This is just an alias for the standard Python error subprocess.CalledProcessError . PackageResolutionError \u00a7 Availability: build.bfg and options.bfg An exception raised when a package resolution function is unable to find the specified package. PackageVersionError \u00a7 Availability: build.bfg and options.bfg An exception raised when a package resolution function found the specified package, but its version doesn't match the version specifier. Derived from both PackageResolutionError and VersionError . VersionError \u00a7 Availability: build.bfg and options.bfg An exception raised when a version fails to match the supplied version specifier.","title":"Builtin Functions"},{"location":"reference/builtins/#builtin-functions","text":"Below are listed all the builtin functions and properties available to bfg9000 scripts ( build.bfg and options.bfg ). Most are only available to build.bfg files, since that's where most of the build configuration logic belongs, but some may be used in options.bfg . Consult each function to see its availability.","title":"Builtin Functions"},{"location":"reference/builtins/#general","text":"","title":"General"},{"location":"reference/builtins/#representing-paths","text":"While all platforms have paths, their representation varies from platform to platform. bfg9000 smooths over these differences by providing a cross-platform representation of paths. Both POSIX- and Windows-style paths are supported and will be translated to a standard internal representation before being emitted to build scripts in their platform-specific form. Thus, foo/bar and foo\\bar are equivalent to bfg9000. In addition, you can terminate a path with / (or \\ ) to ensure that it's treated as a directory; this affects the behavior of some builtins, such as auto_file . Note While absolute paths are rarely needed in a build.bfg script, it's still possible to use them. However, there are some caveats: 1) on Windows, POSIX-style absolute paths will refer to that (absolute) path on the current drive, 2) Windows-style absolute paths will fail to work on POSIX systems, and 3) Windows-style paths with a drive letter and a relative path (e.g. C:foo ) are unsupported by bfg9000.","title":"Representing paths"},{"location":"reference/builtins/#file-objects","text":"Files used in a build.bfg script are divided by their types (e.g. source code, header files, etc). All files from the source directory which are referenced in the build.bfg script will automatically be added to the source distribution when it's built. In most cases, you can simply pass a string to functions expecting a file object; the string will automatically be converted to a file object of the appropriate type. However, in some cases, you may wish to explicitly create a file object. This can be useful, for instance, when running commands that take a source file as an argument, e.g. in the following snippet: command('script', cmd=[source_file('script.py')]) Using source_file here allows you to specify that the file is a source code file found in the source directory , rather than the build directory. Further, since the file is a Python script, it can be executed as part of a command step. In addition to the functions listed in this section below, build steps which generate a file can also be used to produce source files of that type (see each step's documentation for details). Note By default, when creating a file object in the source directory, it will automatically be added to the project's source distribution . To disable this, you can specify dist=False when creating the file object.","title":"File objects"},{"location":"reference/builtins/#auto_file","text":"Create a reference to an existing file named name . This function will try to automatically determine the file's kind based on its extension: source_file ; header_file ; or, if the extension is not recognized, generic_file . If lang is specified, files with an unrecognized extension will always be treated as source_file s. If name ends with a / , auto_file will create a directory instead or, if lang is specified, a header_directory . Note This function is primarily useful for writing generic code that works with multiple kinds of files; when creating a reference to a specific, known file, the concrete function listed above should be used instead.","title":"auto_file(name, [lang], *, [dist])"},{"location":"reference/builtins/#directory","text":"Availability: build.bfg Create a reference to an existing directory named name ; if name is a file object, create a reference to the directory containing that file. The arguments include , extra , exclude , filter , dist , and cache are forwarded to find_files ; if neither include nor extra are specified, find_files will not be called. Any matching files will be added to the project's source distribution .","title":"directory(name, [include], *, [extra], [exclude], [filter], [dist], [cache])"},{"location":"reference/builtins/#extra_dist","text":"Availability: build.bfg Add extra files and dirs to the list of recognized source files. This lets you reference files that are part of the source distribution but which have no impact on the build proper (e.g. READMEs).","title":"extra_dist([files], [dirs])"},{"location":"reference/builtins/#generic_file","text":"Availability: build.bfg Create a reference to an existing file named name .","title":"generic_file(name, *, [dist])"},{"location":"reference/builtins/#header_directory","text":"Availability: build.bfg Create a reference to a directory named name containing header files for the project (if name is a file object, create a reference to the directory containing that file). This can then be used in the include argument when compiling a source file. The arguments include , extra , exclude , filter , dist , and cache are forwarded to find_files , as with directory . If system is True , this directory will be treated as a system directory for compilers that support this.","title":"header_directory(name, [include], [lang], *, [extra], [exclude], [filter], [system], [dist], [cache])"},{"location":"reference/builtins/#header_file","text":"Availability: build.bfg Create a reference to an existing header named name . This is useful if you'd like to install a single header file for your project. If lang is not specified, the language of the file is inferred from its extension.","title":"header_file(name, [lang], *, [dist])"},{"location":"reference/builtins/#man_page","text":"Availability: build.bfg Create a reference to an existing man page named name at the specified level ; if level is unspecified, guess it by the first character of the extension of name . If compress is true, add a build step to gzip the man page and return the compressed file. If compress is 'auto' (the default), gzip the man page only if the gzip command is found on the system.","title":"man_page(name, *, [level], [compress], [dist], [extra_deps], [description])"},{"location":"reference/builtins/#module_def_file","text":"Availability: build.bfg Create a reference to an existing module-definition file named name . Module-definition files are sometimes used when building libraries on Windows.","title":"module_def_file(name, *, [dist])"},{"location":"reference/builtins/#source_file","text":"Availability: build.bfg Create a reference to an existing source file named name . If lang is not specified, the language of the file is inferred from its extension.","title":"source_file(name, [lang], *, [dist])"},{"location":"reference/builtins/#build-steps","text":"Build steps describe how to create a target output (usually a file) from zero or more inputs (usually files or other build steps). As you may expect, if the output is a file and it's either out of date or doesn't exist, the step is run to generate it. Each input is a dependency on the output, and any changes to an input will result in a rebuild. This includes headers #include d by any of the source files, but does not include files external to the project (i.e. packages ). Most build steps also have the ability to define additional dependencies via the extra_deps argument. These can be files or other build steps, and changes to them will trigger a rebuild as with the build's inputs. Further, many build steps also allow setting a custom description . This can be used to provide a friendlier message for the Ninja backend to show when building that step.","title":"Build steps"},{"location":"reference/builtins/#file-steps","text":"Naturally, the most common type of build step is one that generates a file. These are responsible for compiling object files, linking executables and libraries, and so on. In addition, all of these steps can be used like the file object functions described above to refer to prebuilt files already in the source tree (e.g. static libraries provided in binary form by a vendor). This is described in more detail for each step below. Note For file steps, the exact name of the output file is determined by the platform you're running on. For instance, when building an executable file named \"foo\" on Windows, the resulting file will be foo.exe .","title":"File steps"},{"location":"reference/builtins/#copy_file","text":"Availability: build.bfg Create a build step that copies a file named file to a destination named name ; if name is not specified, this function will use the filename in file as a base (this is primarily useful for copying a file from the source directory to the build directory). mode specifies how the file should be copied: 'copy' (the default), 'symlink' , or 'hardlink' . You can also specify directory as an optional subdirectory to place the copied file into if name is unspecified, as with object_file . This build step recognizes the environment variables for the relevant copy mode.","title":"copy_file([name], file, *, [mode], [directory], [extra_deps], [description])"},{"location":"reference/builtins/#copy_files","text":"Availability: build.bfg Create a build step to copy each of the files in files using the specified mode ; this is equivalent to calling copy_file for each element in files . Like object_files , copy_files returns a special list that allows you to index into it using the filename of one of the source files listed in files .","title":"copy_files(files, *, [mode], [extra_deps], [description])"},{"location":"reference/builtins/#executable","text":"Availability: build.bfg Create a build step that builds an executable file named name . files is the list of source (or object) files to link. If an element of files is a source file (or a plain string), this function will implicitly call object_file on it. The following arguments may also be specified: includes : Forwarded on to object_file pch : Forwarded on to object_file libs : A list of library files (see shared_library and static_library ) packages : A list of external packages ; also forwarded on to object_file compile_options : Forwarded on to object_file as options link_options : Command-line options to pass to the linker entry_point : The symbol for beginning execution of this program module_defs : A module_def_file specifying information about exports and other program info, sometimes used on Windows lang : Forwarded on to object_file intermediate_dir : Fowarded on to object_file as directory , defaulting to <name>.int extra_compile_deps : Forwarded on to object_file as extra_deps If neither files nor libs is specified, this function merely references an existing executable file (a precompiled binary, a shell script, etc) somewhere on the filesystem. In this case, name is the exact name of the file, relative to the source directory. This allows you to refer to existing executables for other functions. In addition, the following arguments may be specified: format : The object format of the exectuable; by default, this is the platform's native object format (e.g. 'elf' on Linux) This build step recognizes the dynamic linking environment variables and the compiler environment variable (e.g. CC ) for the relevant language. Note When passing options to the linker via link_options , these options will be passed to whatever executable is typically used to link object files for the source language; in particular, this means that when using a tool like GCC to build your project, any linker options that need to be forwarded on to ld should be prepended with '-Wl,' .","title":"executable(name, [files, *, ..., [extra_deps], [description]])"},{"location":"reference/builtins/#generated_source","text":"Availability: build.bfg Create a build step that generates a source file named name from an input (typically another source file) named file ; if name is not specified, this function will use the filename in file as a base (typically the filename with a different extension). Note that unlike with other file steps, name represents the exact file name to be used for the output file (i.e. the file extension isn't added automatically). The following arguments may also be specified: options : Command-line options to pass to the compiler lang : The language of the source file; useful if the source file's extension isn't recognized by bfg9000 directory : An optional subdirectory to place the source file into if name is unspecified Note When building files via yacc , this step will automatically generate both source and header files named <name>.tab.c and <name>.tab.h . You can force this step to build only the source file by passing a single filename to the name argument; you can also customize the names by passing a pair of filenames: generated_source(['foo.c', 'foo.h'], 'bar.y') This build step recognizes the compilation environment variables for the relevant language.","title":"generated_source([name], file, *, ..., [extra_deps], [description])"},{"location":"reference/builtins/#generated_sources","text":"Availability: build.bfg Create a source-generation build step for each of the files in files ; this is equivalent to calling generated_source for each element in files . Like object_files , generated_sources returns a special list that allows you to index into it using the filename of one of the source files listed in files .","title":"generated_sources(files, *, ..., [extra_deps], [description])"},{"location":"reference/builtins/#library","text":"Availability: build.bfg Create a build step that builds a shared library named name . Its arguments are the same as the superset of shared_library and static_library , with the following additional argument: kind : The kind of library to be built; one of 'shared' , 'static' , or 'dual' (to build both shared and static versions). If not specified, the default behavior depends on the command-line arguments passed to bfg9000. To enable/disable shared libraries, pass --enable-shared / --disable-shared , and for static libraries, pass --enable-static / --disable-static . Like with executable , if files isn't specified, this function merely references an existing library somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. You may also pass in the format argument as with executable . If name refers to a dual-use library, this function will return the library subtype as specified in kind (e.g. passing 'shared' will return the shared version of the library). This build step recognizes the dynamic linking environment variables or the static linking environment variables , as well as the compiler environment variable (e.g. $CC ) for the relevant language. Warning By convention, MSVC uses the same filenames for static libraries as for import libs for shared libraries. As a result, if both shared and static library builds are enabled with MSVC, bfg9000 will fall back to building only the shared library.","title":"library(name, [files, *, ..., [extra_deps], [description]])"},{"location":"reference/builtins/#object_file","text":"Availability: build.bfg Create a build step that compiles a source file named file to an object file named name ; if name is not specified, this function will use the filename in file as a base (typically the filename without the extension). The following arguments may also be specified: includes : A list of directories to search for header files; you may also pass header files , and their directories will be added to the search list pch : A precompiled header to use during compilation libs : A list of library files (see shared_library and static_library ); this is only used by languages that need libraries defined at compile-time, such as Java packages : A list of external packages options : Command-line options to pass to the compiler lang : The language of the source file; useful if the source file's extension isn't recognized by bfg9000 directory : An optional subdirectory to place the object file into if name is unspecified (this is used by executable and friends to place implicitly-defined object files in an intermediate directory) If file isn't specified, this function merely references an existing object file somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. In addition, the following arguments may be specified: format : The object format of the file; by default, this is the platform's native object format (e.g. 'elf' on Linux) lang : The source language of the file; if none is specified, defaults to 'c' This build step recognizes the compilation environment variables for the relevant language.","title":"object_file([name], [file, *, ..., [extra_deps], [description]])"},{"location":"reference/builtins/#object_files","text":"Availability: build.bfg Create a compilation build step for each of the files in files ; this is equivalent to calling object_file for each element in files . In addition, object_files returns a special list that allows you to index into it using the filename of one of the source files listed in files . This makes it easy to extract a single object file to use in other places, e.g. test code. For example: objs = object_files(['foo.cpp', 'bar.cpp']) release_exe = executable('release', objs) foo_obj = objs['foo.cpp'] test_exe = executable('test', ['test.cpp', foo_obj])","title":"object_files(files, *, ..., [extra_deps], [description])"},{"location":"reference/builtins/#precompiled_header","text":"Availability: build.bfg Create a build step that generates a precompiled header, which can be used to speed up the compilation of object files . If name is not specified, it is inferred from the value of file ; the exact name varies based on the compiler being used, but typically looks like header.hpp.pch for cc-like compilers and header.pch for MSVC-like compilers. The arguments for precompiled_header are the same as for object_file , with the following additional argument: pch_source : The source file to be used when building the precompiled header. If this is not specified, a source file will automatically be created, containing nothing but #include \"header\" , where header is the name of the header specified in file . This option only applies to MSVC-like compilers; for all others, it is ignored. If file isn't specified, this function merely references an existing precompiled header somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. In addition, the following argument may be specified: lang : The source language of the file; if none is specified, defaults to 'c' Warning The exact behavior of precompiled headers varies according to the compiler you're using. In GCC and Clang , the header to be precompiled must be the first file #include d in each source file. In MSVC , the resulting precompiled header is actually compiled within the context of a particular source file and will contain all the code up to and including the header in question.","title":"precompiled_header([name], [file, *, ..., [extra_deps], [description]])"},{"location":"reference/builtins/#shared_library","text":"Availability: build.bfg Create a build step that builds a shared library named name . Its arguments are the same as executable , with the following additional arguments: version : The version number of the library, e.g. 1.2.3 . soversion : The API version of the library (used in its soname), e.g. 1 . Like with executable , if files isn't specified, this function merely references an existing shared library somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. You may also pass in the format argument as with executable . If name refers to a dual-use library, this function will return the shared version of the library. This build step recognizes the dynamic linking environment variables and the compiler environment variable (e.g. CC ) for the relevant language. Note On Windows, this produces two files for native-runtime languages (e.g. C or C++): name.dll and name.lib . The latter is the import library , used when linking to this library. Additionally for native languages on Windows, this step will add a preprocessor macro named LIB<NAME>_EXPORTS that can be used for declaring public symbols. See Building libraries on Windows for an example of how to use this macro in your code.","title":"shared_library(name, [files, *, ..., [extra_deps], [description]])"},{"location":"reference/builtins/#static_library","text":"Availability: build.bfg Create a build step that builds a static library named name . Its arguments are the same as executable (however, entry_point cannot be specified for static libraries), with the following additional argument: static_link_options : Command-line options to pass to the linker Other link-related arguments ( link_options , libs , and libraries from packages ) have no direct effect on this build step. Instead, they're cached and forwarded on to any dynamic linking step that uses this static library. Like with executable , if files isn't specified, this function merely references an existing shared library somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. In addition, the following arguments may be specified: format : The object format of the exectuable; by default, this is the platform's native object format (e.g. 'elf' on Linux) lang : The source language(s) of the library; if none is specified, defaults to ['c'] If name refers to a dual-use library, this function will return the static version of the library. This build step recognizes the static linking environment variables . Note On Windows, this step will add a preprocessor macro on Windows named LIB<NAME>_STATIC that can be used for declaring public symbols. See Building libraries on Windows for an example of how to use this macro in your code.","title":"static_library(name, [files, *, ..., [extra_deps], [description]])"},{"location":"reference/builtins/#whole_archive","text":"Availability: build.bfg Create a build step that builds a whole-archive named name . Whole archives ensures that every object file in the library is included, rather than just the ones whose symbols are referenced. This is typically used to turn a static library into a shared library. whole_archive 's arguments are the same as for static_library . In addition, you can pass an existing static library to whole_archive to convert it into a whole archive.","title":"whole_archive(name, [files, *, ..., [extra_deps]])"},{"location":"reference/builtins/#test-steps","text":"These steps help you define automated tests that can all be run via the test target. For simple cases, you should only need the test function, but you can also wrap your tests with a separate driver using test_driver . For cases where you only want to build the tests, not run them, you can use the tests target.","title":"Test steps"},{"location":"reference/builtins/#test","text":"Availability: build.bfg Create a single test. cmd is the base command (possibly with arguments) to run; this works much like the cmd argument in the command built-in. You can also pass temporary environment variables as a dict via environment , or specify a test driver to add this test file to via driver .","title":"test(test, *, [environment|driver])"},{"location":"reference/builtins/#test_driver","text":"Availability: build.bfg Create a test driver which can run a series of tests, specified as command-line arguments to the driver. cmd is the base command (possibly with arguments) to run; this works much like the cmd argument in the command built-in. You can also pass temporary environment variables as a dict with environment , or specify a parent test driver to wrap this driver via parent . Finally, you can specify wrap_children to determine how tests using this driver are run. If true, each test will be wrapped by env.run_arguments ; if false (the default), tests will be used as-is.","title":"test_driver(cmd, *, [environment|parent], [wrap_children])"},{"location":"reference/builtins/#test_deps","text":"Availability: build.bfg Specify a list of extra dependencies which must be satisfied when building the tests via the tests target.","title":"test_deps(...)"},{"location":"reference/builtins/#grouping-steps","text":"","title":"Grouping steps"},{"location":"reference/builtins/#alias","text":"Availability: build.bfg Create a build step named name that performs no actions on its own. Instead, it just runs its dependencies listed in deps as necessary. This build step is useful for grouping common steps together.","title":"alias(name, [deps])"},{"location":"reference/builtins/#default","text":"Availability: build.bfg Specify a list of build outputs that should be run by default when building. These are all accumulated into the all target. If an iterable object is passed as an argument to default , each element of the iterable will be added. If default is never called, all executables and libraries not passed to test will be built by default. To allow this to be chained with other functions, default will return the arguments passed into it: as a single object if one argument is passed, or a tuple if multiple are passed.","title":"default(...)"},{"location":"reference/builtins/#install","text":"Availability: build.bfg Specify a list of files that need to be installed for the project to work. Each will be installed to the appropriate location based on its type, e.g. header files will go in $PREFIX/include by default on POSIX systems. These are all accumulated into the install target. If an iterable object is passed as an argument to install , each element of the iterable will be added. If there are any runtime dependencies for a file (such as shared libraries you just built), they will be installed as well. The install location can be customized via the directory argument. If passed as a string, the value will be appended to the default install location, e.g. install(header_file('foo.hpp'), directory='dir') will install to $INCLUDEDIR/dir/foo.hpp . You can also pass a Path object to override the default install location entirely. To allow referencing the installed copies of the files passed to it, install will return file objects representing the installed files: as a single object if one argument is passed, or a tuple if multiple are passed. Note When explicitly listing a target, all the files for that target will be installed. For instance, on Windows, this means that passing in a shared library will install the DLL and the import library. This step recognizes the following environment variables: $DESTDIR , $INSTALL , $INSTALL_NAME_TOOL , $MKDIR_P , $PATCHELF .","title":"install(..., [directory])"},{"location":"reference/builtins/#user-defined-steps","text":"While the standard build steps cover the most common tasks in a build, many projects need to run more-specialized commands. A build script can define custom steps via the build_step and command functions: build_step defines a step which outputs one or more files that can be used in other steps, while command defines a more general step that should always be run when it's a target (similar to the test or install targets). Both build_step and command allow you to specify an arbitrary command cmd or cmds ; cmd takes a single command, whereas cmds takes a list of commands. Each command will be passed through env.run_arguments() and may be a string (to be parsed according to shell rules), a file object (such as an executable ), or a list of arguments to be passed directly to the process. Any file objects specified in the command will automatically be added as dependencies to this step. In addition, commands can include placeholders , which will automatically be expanded to the files corresponding to that placeholder. You may also pass a dict to environment to set environment variables for the commands. These override any environment variables set on the command line.","title":"User-defined steps"},{"location":"reference/builtins/#build_step","text":"Availability: build.bfg Create a custom build step that produces one or more files named name by running an arbitrary command ( cmd or cmds ). name may either be a single file name or a list of file names. If always_outdated is true, this build step will be considered out-of-date no matter the status of the output. The command argument can use the placeholders build_step.output to refer to the output files (defined by name ) and build_step.input to refer to the input files (defined by files ). By default, the output of this step is one or more auto_file s; you can adjust this with the type argument: this should be a function (or a list thereof) taking a path and returning a file object. If type is a single function, it will be applied to every output of build_step ; if it's a list of functions, they will be applied element-wise to each output.","title":"build_step(name, *, cmd|cmds, [files], [environment], [type], [always_outdated], [extra_deps], [description])"},{"location":"reference/builtins/#command","text":"Availability: build.bfg Create a build step named name that runs an arbitrary command, specified in either cmd or cmds . This build step is always considered out-of-date (as with a \"phony\" Makefile target, such as test or install ). The command argument can use the placeholder command.input to refer to the input files (defined by files ).","title":"command(name, *, cmd|cmds, [files], [environment], [extra_deps], [description])"},{"location":"reference/builtins/#placeholder","text":"Availability: build.bfg When used in the cmd or cmds argument of build_step or command , this will create a reference to the inputs or outputs of the step. Placeholders can be indexed or sliced just like ordinary Python lists, and can also be combined with strings to add prefixes and suffixes: script = source_file('script.py') # Roughly equivalent to `python script.py -ifoo.txt -sbar.txt -squux.txt` command('foo', cmd=[ script, '-i' + command.input[0], '-s' + command.input[1:] ], files=['foo.txt', 'bar.txt', 'quux.txt'])","title":"placeholder"},{"location":"reference/builtins/#semantic-options","text":"Semantic options are a collection of objects that allow a build to define options in a tool-agnostic way. These options will automatically be converted to the appropriate string form for the tool when generating the build file.","title":"Semantic options"},{"location":"reference/builtins/#opts-debug","text":"Produce debugging information for the built object in the default debugging format. When using MSVC, this also determines whether to link to debug or release variants of the runtime.","title":"opts.debug()"},{"location":"reference/builtins/#opts-define","text":"Create a preprocessor macro named name and with an optional value value . Note that if you'd like the value to be a string literal, you need to escape the string like so: opts.define('MY_MACRO', '\"This is a string, isn\\'t it?\"')","title":"opts.define(name, [value])"},{"location":"reference/builtins/#opts-entry_point","text":"Set the symbol to use for beginning program execution. This is equivalent to passing entry_point=value to executable or shared_library .","title":"opts.entry_point(value)"},{"location":"reference/builtins/#opts-gui","text":"Generate a graphical program; this is important for Windows builds, since the default is to generate a command-line program that opens a terminal window. On Windows, this option sets the subsystem to WINDOWS ; if main is true, it also sets the entry point to mainCRTStartup (which calls the standard main function instead of the Windows-specific WinMain ). On other platforms, this option has no effect.","title":"opts.gui([main])"},{"location":"reference/builtins/#opts-optimize","text":"Set the level of optimization for the compiler employ; multiple values can be specified at once, e.g. opts.optimize('speed, 'linktime) . The possible warning values are: 'disable' : Disable all optimization 'size' : Enable optimization to minimize the size of the resulting binary 'speed' : Enable optimization to maximize the speed of the resulting binary 'linktime' : Perform link-time optimizations","title":"opts.optimize(...)"},{"location":"reference/builtins/#opts-sanitize","text":"Enable run-time sanitization checks when compiling a particular source file; this is equivalent to -fsanitize=address on GCC-like compilers and /RTC1 on MSVC.","title":"opts.sanitize()"},{"location":"reference/builtins/#opts-static","text":"When linking to libraries, only link statically.","title":"opts.static()"},{"location":"reference/builtins/#opts-std","text":"Specify the version of the language's standard (e.g. \"c++14\" ) to use when building.","title":"opts.std(value)"},{"location":"reference/builtins/#opts-warning","text":"Set the level of warnings for the compiler to emit when compiling; multiple values can be specified at once, e.g. opts.warning('all', 'error') . The possible warning values are: 'disable' : Disable all warning messages 'all' : Enable all \"recommended\" warnings (as GCC puts it, \"the warnings about constructions that some users consider questionable, and that are easy to avoid\") 'extra' : Enable extra warnings in addition to what's specified in 'all' 'error' : Treat any warning as an error","title":"opts.warning(...)"},{"location":"reference/builtins/#global-options","text":"","title":"Global options"},{"location":"reference/builtins/#global_options","text":"Availability: build.bfg Specify some options (either as a string or list) to use for all compilation steps for the language (or list of languages) lang .","title":"global_options(options, lang)"},{"location":"reference/builtins/#global_link_options","text":"Availability: build.bfg Specify some options (either as a string or list) to use for all link steps for a given family of languages (or a list of families) and linking mode . By default family is 'native' , used for C, C++, and other languages using the same linking process. You can also specify 'jvm' for JVM-based languages (Java, Scala). mode may be either 'dynamic' (the default) to modify executables and shared libraries or 'static' to modify static libraries . Note As with the link_options argument for executable() and shared_library() , dynamic link options will be passed to whatever executable is typically used to link object files for the source language; in particular, this means that when using a tool like GCC to build your project, any linker options that need to be forwarded on to ld should be prepended with '-Wl,' .","title":"global_link_options(options, [family], [mode])"},{"location":"reference/builtins/#package-resolvers","text":"","title":"Package resolvers"},{"location":"reference/builtins/#framework","text":"Reference a macOS framework named name with the optional suffix suffix . Though not a \"package\" in name, this can be used wherever packages are accepted.","title":"framework(name, [suffix])"},{"location":"reference/builtins/#package","text":"Availability: build.bfg Search for a package named name optionally containing one or more submodules . lang is the source language of the package (if not specified, this will use the default language for the project); this will affect how the package is resolved. For native packages (C, C++, Fortran, etc), this will use mopack to resolve the package; otherwise, this will use a language-specific check to find packages on the system. If this function is unable to find the package, it will raise a PackageResolutionError . You can also specify kind to one of 'any' (the default), 'shared' , or 'static' . This allows you to restrict the search to find only static versions of a library, for example. If system is True (the default), any directories will be treated as system directories for compilers that support this. If version is specified, it will (if possible) ensure that the installed version of the package meets the version requirement; it must be formatted as a Python version specifier . If this check fails, a PackageVersionError will be raised. When calling this function, you can exclude the submodules argument and pass a version as the second positional argument if it's parseable as a version specifier. For example, package('pkg', '>=1.0') . This function recognizes the following environment variables: $CLASSPATH , $CPATH , $INCLUDE , $LIB , $LIBRARY_PATH , $PKG_CONFIG . Note This function can also be used to refer to the pthread library. On many Unix-like systems, instead of using -lpthread during the link step, it's preferred to use -pthread during compilation and linking. Using package('pthread') will handle this automatically.","title":"package(name, [submodules], [version], *, [lang], [kind], [system])"},{"location":"reference/builtins/#pkg_config","text":"Availability: build.bfg Create pkg-config information for this project and install it along with the rest of the installed files. In addition, create an -uninstalled variant of the pkg-config file to allow it to be used prior to installing the project. All of the arguments below are optional and will be automatically inferred from the rest of the build where possible. Unless otherwise noted, these arguments correspond directly to the fields in the pkg-config .pc file. name : The name of the package (to be used as the name of the .pc file) desc_name : A human-readable name for the package (stored as the Name field in pkg-config); defaults to name desc : A brief description of the package; defaults to <name> library url : A URL where users can learn more about the package version : The package's version requires : A list of packages required by this package; these can be strings, a string and version specifier, or the results from package . In the last case, packages resolved by pkg-config are added directly as requirements; those resolved by other means are added to the Libs field in pkg-config requires_private : A list of packages required by this package but not exposed to users; these can be specified as with requires conflicts : A list of packages that conflict with this package; these can be specified as with requires includes : A list of directories (or header files ) to add to the search path for users of this package libs : A list of libraries for users of this package to link to; any dependent libraries, packages, or link options (in the case of static libs) will automatically be added to libs_private , requires_private , and link_options_private , respectively libs_private : A list of libraries required by this package but not exposed to users (this is used primarily for static linking); dependent libraries, packages, and link options are added as with libs options : A list of compile options for this package link_options : A list of link options for this package link_options_private : A list of link options for this package but not exposed to users (this is used primarily for static linking) lang : The language of the builder to use when generating option strings; by default, 'c' system : If True , any include directories will be treated as system directories when using the package internally (for compilers that support this); defaults to False . If auto_fill is true, this function will automatically fill in default values for the following fields: name : The project's name (this also fills in desc_name and desc with default values) version : The project's version , or 0.0 if none is specified includes : The list of installed header files/directories libs : The list of installed library files If auto_fill is false, this function will return a package object that can be used in other build steps as normal.","title":"pkg_config([name], *, [version], [includes], [libs], [auto_fill], ...)"},{"location":"reference/builtins/#system_executable","text":"Availability: build.bfg Search for an executable named name somewhere in the system's $PATH . If format is unset, the executable's object format will be set to the default for the host platform. This function recognizes the following environment variables: $PATH , $PATHEXT .","title":"system_executable(name, [format])"},{"location":"reference/builtins/#environment","text":"Occasionally, build scripts need to directly query aspects of the environment. In bfg9000, this is performed with the environment object and its various members.","title":"Environment"},{"location":"reference/builtins/#environment-object","text":"The environment , env , is a special object that encapsulates information about the system outside of bfg9000. It's used internally for nearly all platform-specific code, but it can also help in build.bfg (or options.bfg !) files when you encounter some unavoidable issue with multiplatform compatibility. Note This listing doesn't cover all available functions on the environment, since many are only useful to internal code. However, the most relevant ones for build.bfg files are shown below.","title":"Environment object"},{"location":"reference/builtins/#env-builder","text":"Return the builder used by bfg9000 for a particular language lang .","title":"env.builder(lang)"},{"location":"reference/builtins/#env-execute","text":"Execute the command-line arguments in args and return the output. If shell is true, args should be a string that will be interpreted by the system's shell; if not (the default), it should be a series of arguments. You can also set env to be a dictionary of environment variables to pass to the child process; if env is None (the default), the environment variables in env.variables will be used instead. Similarly, you can set extra_env to be a dict of env vars; these will be added to the dict in env (or to env.variables if env is None ) to produce the final set of environment variables to pass to the child process. stdout and stderr are env.Mode values that describe how (or if) output should be redirected. By default, both are set to Mode.normal . Finally, returncode specifies the expected return code from the subprocess. This is 0 by default, and may be either a number, a list of numbers, or 'any' to match any return code. If the return code fails to match, a CalledProcessError will be thrown.","title":"env.execute(args, *, [env], [extra_env], [shell], [stdout], [stderr], [returncode])"},{"location":"reference/builtins/#env-getvar","text":"Equivalent to env.variables .get(name, default) .","title":"env.getvar(name, [default])"},{"location":"reference/builtins/#env-host_platform","text":"Return the host platform used for the build.","title":"env.host_platform"},{"location":"reference/builtins/#env-Mode","text":"An enumeration of output modes for env.execute and env.run . Possible values are: normal : Perform no redirection and output to stdout/stderr normally pipe : Pipe the output and return it to the calling process stdout : Pipe stderr output to stdout devnull : Pipe output to /dev/null or equivalent","title":"env.Mode"},{"location":"reference/builtins/#env-run_arguments","text":"Generate the arguments needed to run the command in args . If args is a file type (or a list beginning with a file type) such as an executable , it will be prepended with the runner for lang as needed. If lang is None , the language will be determined by the language of args 's first element.","title":"env.run_arguments(args, [lang])"},{"location":"reference/builtins/#env-run","text":"Run a command, generating any arguments needed to perform the operation. Equivalent to env.execute(env.run_arguments(arg, lang), ...) .","title":"env.run(args, *, [lang], [env], [extra_env], [stdout], [stderr], [returncode])"},{"location":"reference/builtins/#env-host_platform","text":"Return the target platform used for the build.","title":"env.host_platform"},{"location":"reference/builtins/#env-tool","text":"Return the tool named name .","title":"env.tool(name)"},{"location":"reference/builtins/#env-variables","text":"A dict of all the environment variables as they were defined when the build was first configured.","title":"env.variables"},{"location":"reference/builtins/#builders","text":"Builder objects represent the toolset used to build executables and libraries for a particular source language. They can be retrieved via env.builder . While builder objects are primarily suited to bfg's internals, there are still a few useful properties for build.bfg files:","title":"Builders"},{"location":"reference/builtins/#builder-flavor","text":"The \"flavor\" of the builder, i.e. the kind of command-line interface it has. Possible values are 'cc' , 'msvc' , and 'jvm' .","title":"builder.flavor"},{"location":"reference/builtins/#builder-brand","text":"The brand of the builder, i.e. the command name people use for it. Currently, for languages in the C family (including Fortran), this is one of 'gcc' , 'clang' , 'msvc' , or 'unknown' . For languages in the Java family, this is one of 'oracle' , 'openjdk' , 'epfl' (for Scala), or 'unknown' .","title":"builder.brand"},{"location":"reference/builtins/#builder-version","text":"The version of the builder (specifically, the version of the primary compiler for the builder). May be None if bfg9000 was unable to detect the version.","title":"builder.version"},{"location":"reference/builtins/#builder-lang","text":"The language of the source files that this builder is designed for.","title":"builder.lang"},{"location":"reference/builtins/#builder-object_format","text":"The object format that the builder outputs, e.g. 'elf' , 'coff' , or 'jvm' .","title":"builder.object_format"},{"location":"reference/builtins/#builder-compiler","text":"The compiler used with this builder.","title":"builder.compiler"},{"location":"reference/builtins/#builder-compiler","text":"The compiler used to build precompiled headers with this builder. May be None for languages or toolsets that don't support precompiled headers.","title":"builder.compiler"},{"location":"reference/builtins/#builder-linker","text":"The linker used with this builder. mode is one of 'executable' , 'shared_library' , or 'static_library' Its public properties are the same as compiler . cc -like builders also support a mode of 'raw' , which returns an object representing the actual linker, such as ld .","title":"builder.linker(mode)"},{"location":"reference/builtins/#builder-runner","text":"The runner used with files built by this builder (e.g. java ). This may be None for languages which have no runner, such as C and C++.","title":"builder.runner"},{"location":"reference/builtins/#compilers","text":"Compiler and linker objects represent the specific tool used to compile a source file (generally into an object file ) or to link a set of object files (generally into an executable or library ).","title":"Compilers/linkers"},{"location":"reference/builtins/#compiler-flavor","text":"The \"flavor\" of the compiler, i.e. the kind of command-line interface it has; e.g. 'cc' , 'msvc' .","title":"compiler.flavor"},{"location":"reference/builtins/#compiler-brand","text":"The brand of the compiler; typically the same as builder.brand .","title":"compiler.brand"},{"location":"reference/builtins/#compiler-version","text":"The version of the compiler; typically the same as builder.version .","title":"compiler.version"},{"location":"reference/builtins/#compiler-language","text":"The language of the compiler; typically the same as builder.language .","title":"compiler.language"},{"location":"reference/builtins/#compiler-command","text":"The command to run when invoking this compiler, represented as a list, e.g. ['g++'] .","title":"compiler.command"},{"location":"reference/builtins/#compiler-found","text":"Whether the command for this compiler was found on the system.","title":"compiler.found"},{"location":"reference/builtins/#tools","text":"Tool objects represent a specific command used to perform some task (usually during a build), such as 'copy' or 'rm' . They can be retrieved via env.tool . While tool objects are primarily suited to bfg's internals, there are still a few useful properties for build.bfg files:","title":"Tools"},{"location":"reference/builtins/#tool-command","text":"The command to run when invoking this tool, represented as a list, e.g. ['cp', '-f'] .","title":"tool.command"},{"location":"reference/builtins/#tool-found","text":"Whether this tool was found on the system.","title":"tool.found"},{"location":"reference/builtins/#platforms","text":"Platform objects represent the platform that the project is being compiled for.","title":"Platforms"},{"location":"reference/builtins/#platform-flavor","text":"The family of the platform. Either 'posix' or 'windows' .","title":"platform.family"},{"location":"reference/builtins/#platform-genus","text":"The sub-type of the platform, e.g. 'linux' , darwin' , or 'winnt' .","title":"platform.genus"},{"location":"reference/builtins/#platform-name","text":"An alias for platform.species .","title":"platform.name"},{"location":"reference/builtins/#platform-species","text":"The specific name of the platform, e.g. 'linux' , 'macos' , or 'winnt' .","title":"platform.species"},{"location":"reference/builtins/#utilities","text":"","title":"Utilities"},{"location":"reference/builtins/#argument","text":"Availability: options.bfg Define how a particular command-line argument will be parsed. names is a sequence of argument names; these will be prefixed with -- and --x- for parsing. For example, passing 'foo' will add --foo and --x-foo as possible command-line arguments. All other arguments to this function have the same behavior as in argparse.ArgumentParser.add_argument() , with the exception of action , which accepts two extra values: 'enable' : Add a pair of arguments of the form --enable-<name> and --disable-<name> (with --x- -prefixed versions as well), storing True if --enable-<name> is specified and False if --disable-<name> is. 'with' : As 'enable' , except the arguments are of the form --with-<name> and --without-name .","title":"argument(names..., [action], [nargs], [const], [default], [type], [choices], [required], [help], [metavar], [dest])"},{"location":"reference/builtins/#argv","text":"Availability: build.bfg Retrieve the set of user-defined arguments passed to bfg9000; this is an argparse.Namespace object.","title":"argv"},{"location":"reference/builtins/#__bfg9000__","text":"Availability: build.bfg , options.bfg , and <toolchain>.bfg A dictionary containing all the builtin functions and global variables defined by bfg9000. This can be useful for feature detection or accessing builtins shadowed by a local variable.","title":"__bfg9000__"},{"location":"reference/builtins/#bfg9000_required_version","text":"Availability: build.bfg , options.bfg , and <toolchain>.bfg Set the required version for bfg9000 and/or the required python_version . Each of these is a standard Python version specifier . If the actual versions don't match the specifiers, a VersionError is raised.","title":"bfg9000_required_version([version], [python_version])"},{"location":"reference/builtins/#bfg9000_version","text":"Availability: build.bfg , options.bfg , and <toolchain>.bfg Return the current version of bfg9000. This can be useful if you want to optionally support a feature only available in certain versions of bfg.","title":"bfg9000_version"},{"location":"reference/builtins/#debug","text":"Availability: build.bfg , options.bfg , and <toolchain>.bfg Log a debug message with the specified arguments separated by spaces (as with print() ). If show_stack is true (the default), show the stack trace where the message was logged from. Note Debug messages are hidden by default; pass --debug on the command line to them.","title":"debug(..., [show_stack])"},{"location":"reference/builtins/#export","text":"Availability: build.bfg and options.bfg Within a submodule , export a list of keyword arguments to be returned to the calling module.","title":"export(...)"},{"location":"reference/builtins/#filter_by_platform","text":"Availability: build.bfg Return FindResult.include if path is a filename that should be included for the target platform, and FindResult.not_now otherwise. File (or directory) names like PLATFORM or foo_PLATFORM.cpp are excluded if PLATFORM is a known platform name that doesn't match the target platform. Known platform names are: 'posix' , 'linux' , 'darwin' , 'cygwin' , 'windows' , 'winnt' , 'win9x' , 'msdos' . This can be used as the filter for find_files or find_path .","title":"filter_by_platform(path)"},{"location":"reference/builtins/#findresult","text":"Availability: build.bfg An enum to be used as the result of a filter function for find_files . The possible enum values are: include : Include this file in the results not_now : Don't include this file in the results, but do include it in the source distribution exclude : Don't include this file in the results exclude_recursive : Don't include this directory or any of its contents in the results","title":"FindResult"},{"location":"reference/builtins/#find_files","text":"Availability: build.bfg Find files that match the glob (or list of globs) pattern , returning them as file objects . Globs work much the same as in POSIX shells, with support for the following patterns: * : 0 or more of any character ? : 1 of any character [abc] : any one character in abc [!abc] : any one character not in abc ** : 0 or more path components (subdirectories, files) By default, globs that end with a / will match only directories, while globs not ending with / will match only files. In addition, globs may be passed as path objects , allowing you to specify a different root to find files in (e.g. the build directory). \"Simple\" globs, used for extra and exclude (see below) support all of the above except for ** , and are matched against only the basename of each file. By default, several globs ( .#* , *~ , and #*# ) are excluded; this can be customized via the find_exclude argument to project . The following arguments may also be specified: type : A filter for the type of file: 'f' to find only files, 'd' to find only directories, or '*' to find either; if not specified, the type will be inferred by the glob itself, as described above extra : A simple glob (or list thereof) to match \"extra\" files; these will not be returned from find_files but will be added to the source distribution ) exclude : A simple glob (or list thereof) of files to exclude from results; if a directory is matched, it and all of its children will be excluded filter : A predicate taking a Path object and returning a FindResult which will filter the results file_type : The type of object to return for matching files; if specified, this should be a function taking a path object and a boolean (the dist argument below), otherwise an auto_file will be returned dir_type : The type of object to return for matching directories, as with file_type ; the default type is a directory dist : If true (the default), all files found by this function will automatically be added to the source distribution cache : If true (the default), cache the results so that any changes to will regenerate the build scripts for the project The cache argument is particularly important. It allows you to add or remove source files and not have to worry about manually rerunning bfg9000.","title":"find_files([pattern], *, [type], [extra], [exclude], ...)"},{"location":"reference/builtins/#find_paths","text":"Availability: build.bfg Find files that match the glob (or list of globs) pattern , returning them as path objects . The arguments to this function are the same as for find_files .","title":"find_paths([pattern], *, [type], [extra], [exclude], ...)"},{"location":"reference/builtins/#info","text":"Availability: build.bfg , options.bfg , and <toolchain>.bfg Log an informational message with the specified arguments separated by spaces (as with print() ). If show_stack is true, show the stack trace where the message was logged from.","title":"info(message, [show_stack])"},{"location":"reference/builtins/#installroot","text":"Availability: build.bfg , options.bfg , and <toolchain>.bfg An enumeration of root directories for Path objects, to be used during installation. Possible values are: prefix : A path relative to the prefix where the build will be installed exec_prefix : A path relative to the prefix where executable code (binaries and libraries) will be installed bindir : A path relative to where binaries will be installed libdir : A path relative to where libraries will be installed includedir : A path relative to where header files will be installed datadir : A path relative to where data files will be installed mandir : A path relative to where man pages will be installed","title":"InstallRoot"},{"location":"reference/builtins/#Path","text":"Availability: build.bfg , options.bfg , and <toolchain>.bfg Create a new path object for a given path . root may be a value in the Root or InstallRoot enumerations, or another Path object. When the root is a value in InstallRoot , you can also specify destdir ; if true, this path will be prepended with $DESTDIR on platforms that support destdirs. When the root is another path, this constructor will return the same value as root.append(path) .","title":"Path(path, [root], [destdir])"},{"location":"reference/builtins/#Path-addext","text":"Append the extension ext to this path and return the new path. Note that ext should include the leading dot, e.g. '.txt' .","title":"Path.addext(ext)"},{"location":"reference/builtins/#Path-append","text":"Append a new path component to this path and return the result.","title":"Path.append(path)"},{"location":"reference/builtins/#Path-basename","text":"Return the basename (the last path component) of this path.","title":"Path.basename()"},{"location":"reference/builtins/#Path-ext","text":"Return the extension of this path, if any; otherwise, return '' .","title":"Path.ext()"},{"location":"reference/builtins/#Path-parent","text":"Return the parent of this path as a new Path object.","title":"Path.parent()"},{"location":"reference/builtins/#Path-relpath","text":"Return a string representing this path's location relative to a starting path start . Both paths should have the same Root . If localize is true (the default), this function will translate the path to the native form for the host platform; otherwise, it will return it untranslated (using POSIX-style separators).","title":"Path.relpath(start, [prefix], [localize])"},{"location":"reference/builtins/#Path-reroot","text":"Return a new Path object with the same path suffix as this path, but with the path root set to root .","title":"Path.reroot(root)"},{"location":"reference/builtins/#Path-root","text":"Return the Root of this path.","title":"Path.root"},{"location":"reference/builtins/#Path-split","text":"Split this path's suffix into a list of its components.","title":"Path.split()"},{"location":"reference/builtins/#pathsplitleaf","text":"Split the leaf component of this path and return the parent and leaf. Equivalent to (path.parent(), path.basename()) .","title":"Path.splitleaf()"},{"location":"reference/builtins/#Path-suffix","text":"Return the suffix of this path (the portion that would be appended to the path's root .","title":"Path.suffix"},{"location":"reference/builtins/#Path-stripext","text":"Remove the extension from this path and replace it with an optional new extension specified in replace , returning the newly-created Path object.","title":"Path.stripext([replace])"},{"location":"reference/builtins/#path_exists","text":"Return whether the path named name exists on the filesystem. name can be either a string or a path object .","title":"path_exists(name)"},{"location":"reference/builtins/#project","text":"Availability: build.bfg Set the name and/or version of the project. If you don't call this function to specify a project name, it defaults to the name of the project's source directory. This is primarily useful for creating source distributions . In addition, you can set a number of project-wide options with this function: intermediate_dirs : (Default True ) Automatically place implicitly-generated intermediate files into separate directories lang : (Default 'c' ) The default language to use for objects that can't infer their language from a file extension (e.g. packages , object files , libraries ) find_exclude : (Default ['.*#', '*~', '#*#'] ) A list of \"simple\" globs to exclude by default when calling find_files or find_paths","title":"project([name], [version], ...)"},{"location":"reference/builtins/#root","text":"Availability: build.bfg , options.bfg , and <toolchain>.bfg An enumeration of root directories for Path objects. Possible values are: srcdir : A path relative to the project's source directory builddir : A path relative to the build directory absolute : An absolute path","title":"Root"},{"location":"reference/builtins/#safe_format","text":"Availability: build.bfg , options.bfg , and <toolchain>.bfg Safely format a string fmt , as with str.format . Unlike str.format however, this converts placeholders to string via safe_str , ensuring that the result is correctly-escaped when used in a build script.","title":"safe_format(fmt, ...)"},{"location":"reference/builtins/#safe_str","text":"Availability: build.bfg , options.bfg , and <toolchain>.bfg Convert an object s into a \"safe\" string, if possible. Safe strings are used by the build backends to correctly handle escaping special characters as needed.","title":"safe_str(s)"},{"location":"reference/builtins/#submodule","text":"Availability: build.bfg and options.bfg Include and execute the build.bfg (or options.bfg , as appropriate) file contained in the submodule path . Within the submodule's bfg file, all paths for inputs (source files) and outputs (built files) are evaluated relative to path . This function returns a dict of all the exported objects from the submodule's bfg file.","title":"submodule(path)"},{"location":"reference/builtins/#warning","text":"Availability: build.bfg , options.bfg , and <toolchain>.bfg Log a warning with the specified arguments separated by spaces (as with print() ) and the stack trace where the warning was emitted.","title":"warning(...)"},{"location":"reference/builtins/#toolchain","text":"","title":"Toolchain"},{"location":"reference/builtins/#compiler","text":"Availability: <toolchain>.bfg Set the compiler to use for the language lang . names is a string representing the path to the compiler (resolved as with which ) or a list of possible paths (as strings or lists or strings). If strict is true, compiler will raise an IOError if an executable cannot be found; if false, it will use the first candidate.","title":"compiler(names, lang)"},{"location":"reference/builtins/#compile_options","text":"Availability: <toolchain>.bfg Set compilation options to use for the language lang . options is either a string of all the options or a list of strings, one element per option. Note Semantic options aren't supported here; instead, you should use the appropriate option strings for the compiler to be used.","title":"compile_options(options, lang)"},{"location":"reference/builtins/#environ","text":"Availability: <toolchain>.bfg A dict of the current environment variables, suitable for getting/setting.","title":"environ"},{"location":"reference/builtins/#install_dirs","text":"Availability: <toolchain>.bfg Set the installation directories for this toolchain. Arguments to this function should be keyword args with one of the following names: prefix , exec_prefix , bindir , libdir , or includedir . Note Any installation directory set here overrides directories set on the command line.","title":"install_dirs([...])"},{"location":"reference/builtins/#lib_options","text":"Availability: <toolchain>.bfg Set lib options to use for the format format (defaults to 'native' ) and mode mode (defaults to 'dynamic' ). options is either a string of all the options or a list of strings, one element per option. Unlike link_options , this is used to specify options which appear at the end of a linker command (like $LDLIBS ).","title":"lib_options(options, [format], [mode])"},{"location":"reference/builtins/#linker","text":"Availability: <toolchain>.bfg Set the link to use for the format format (defaults to 'native' ) and mode mode (defaults to 'dynamic' ). names is a string representing the path to the linker (resolved as with which ) or a list of possible paths (as strings or lists or strings). If strict is true, linker will raise an IOError if an executable cannot be found; if false, it will use the first candidate.","title":"linker(names, [format], [mode])"},{"location":"reference/builtins/#link_options","text":"Availability: <toolchain>.bfg Set link options to use for the format format (defaults to 'native' ) and mode mode (defaults to 'dynamic' ). options is either a string of all the options or a list of strings, one element per option.","title":"link_options(options, [format], [mode])"},{"location":"reference/builtins/#runner","text":"Availability: <toolchain>.bfg Set the runner to use for the language lang , if that language supports runners (e.g. Java, Scala, or a scripting language). names is a string representing the path to the compiler (resolved as with which ) or a list of possible paths (as strings or lists or strings). If strict is true, compiler will raise an IOError if an executable cannot be found; if false, it will use the first candidate.","title":"runner(names, lang)"},{"location":"reference/builtins/#srcdir","text":"Availability: <toolchain>.bfg Return the source directory of this project as a Path object.","title":"srcdir"},{"location":"reference/builtins/#target_platform","text":"Availability: <toolchain>.bfg Set the target platform of this build to platform and the architecture to arch . If either is not specified, the host system's platform/arch will be used. The following platforms are recognized: 'android' , 'cygwin' , 'ios' , 'linux' , 'macos' , 'win9x' , and 'winnt' . Other platforms (e.g. 'freebsd' ) can be specified, and will be treated as generic POSIX platforms.","title":"target_platform([platform], [arch])"},{"location":"reference/builtins/#which","text":"Availability: <toolchain>.bfg Find the best option for an executable named by names . names can be a string resolved as with the $PATH environment variable in the shell, or else a list of names (as strings or lists of strings). If names contains a list-of-lists, the inner list represents a series of arguments to pass to the executable when running it. If strict is true (the default), which will raise an IOError if an executable cannot be found; if false, it will return the first candidate as a string.","title":"which(names, [resolve], [strict])"},{"location":"reference/builtins/#exceptions","text":"","title":"Exceptions"},{"location":"reference/builtins/#calledprocesserror","text":"Availability: build.bfg and options.bfg An exception raised when a subprocess fails to execute successfully. This is just an alias for the standard Python error subprocess.CalledProcessError .","title":"CalledProcessError"},{"location":"reference/builtins/#packageresolutionerror","text":"Availability: build.bfg and options.bfg An exception raised when a package resolution function is unable to find the specified package.","title":"PackageResolutionError"},{"location":"reference/builtins/#packageversionerror","text":"Availability: build.bfg and options.bfg An exception raised when a package resolution function found the specified package, but its version doesn't match the version specifier. Derived from both PackageResolutionError and VersionError .","title":"PackageVersionError"},{"location":"reference/builtins/#versionerror","text":"Availability: build.bfg and options.bfg An exception raised when a version fails to match the supplied version specifier.","title":"VersionError"},{"location":"reference/command-line/","text":"Command-Line Reference \u00a7 Global options \u00a7 -h , --help \u00a7 Print a help message and exit. Equivalent to the help subcommand. --version \u00a7 Print the version number and exit. -c , --color WHEN \u00a7 Show colored output; WHEN is one of always , never , or auto and defaults to auto (i.e. show colored output when the terminal is a tty). -c is equivalent to --color=always . --warn-once \u00a7 Only emit a given warning once. Sub-commands \u00a7 bfg9000 help [ SUBCOMMAND ] \u00a7 Print a help message and exit. If SUBCOMMAND is specified, print help for that subcommand. bfg9000 configure DIRECTORY \u00a7 Generate the necessary build files to perform actual builds. If DIRECTORY is a source directory (i.e. it contains a build.bfg file), the build files will be created in the current directory. Otherwise, DIRECTORY is treated as the build directory, and bfg9000 will look for a build.bfg file in the current directory. -B BACKEND , --backend BACKEND \u00a7 The kind of build files to generate; one of ninja , make , or msbuild . The default value depends on what build backends you have installed, but if ninja is present on your system, it will be the default. --toolchain FILE \u00a7 An optional toolchain file that can be used to easily set all the options required for a certain build. --enable-shared , --disable-shared \u00a7 Enable/disable building shared libraries when using library () in your build.bfg files. Defaults to enabled. --enable-static , --disable-static \u00a7 Enable/disable building static libraries when using library () in your build.bfg files. Defaults to enabled. --enable-compdb , --disable-compdb \u00a7 Enable/disable generation of compile_commands.json when generating build files. Defaults to enabled. -p FILE , --package-file FILE \u00a7 Additional mopack package files to consult when resolving packages. -P FLAG , --package-flag FLAG \u00a7 Additional mopack flags to use when resolving packages. --no-resolve-packages \u00a7 Disable resolution of package dependencies via mopack . --prefix PATH \u00a7 The installation prefix to use when installing built files. On Linux and macOS, this defaults to /usr/local ; on Windows, there is no default (thus, to install built files on Windows, you must either set --prefix or one of the other install path options below). --exec-prefix PATH \u00a7 The installation prefix to use when installing architecture-dependent files (e.g. executables). This defaults to the value of --prefix . --bindir PATH \u00a7 The installation prefix to use for executables. Defaults to <exec-prefix>/bin on Linux and macOS, and <exec-prefix> on Windows. --libdir PATH \u00a7 The installation prefix to use for libraries. Defaults to <exec-prefix>/lib on Linux and macOS, and <exec-prefix> on Windows. --includedir PATH \u00a7 The installation prefix to use for headers. Defaults to <prefix>/include on Linux and macOS, and <prefix> on Windows. --datadir PATH \u00a7 The installation prefix to use for data files. Defaults to <prefix>/share on Linux and macOS, and <prefix> on Windows. --mandir PATH \u00a7 The installation prefix to use for man pages. Defaults to <datadir>/man . bfg9000 configure-into SRCDIR BUILDDIR \u00a7 Generate the necessary build files (as with bfg9000 configure ) to perform actual builds from a build.bfg file in SRCDIR , and place them in BUILDDIR . bfg9000 refresh [ BUILDDIR ] \u00a7 Regenerate an existing set of build files in BUILDDIR needed to perform actual builds. This is run automatically if bfg9000 determines that the build files are out of date. bfg9000 env [ BUILDDIR ] \u00a7 Print the environment variables stored by the build configuration in BUILDDIR . -u , --unique \u00a7 Only show environment variables that differ from the current environment. bfg9000 run COMMAND \u00a7 Run an arbitrary COMMAND with the environment variables set for the current build. -I , --initial \u00a7 Use the initial environment variables, before any modification by toolchain files. -B BUILDDIR , --builddir BUILDDIR \u00a7 Set the build directory to pull environment variable state from. bfg9000 generate-completion \u00a7 Generate shell-completion functions for bfg9000 and write them to standard output. This requires the Python package shtab . -p PROGRAM , --program PROGRAM \u00a7 Specify the program to generate completion for: bfg9000 (the default) or 9k . -s SHELL , --shell SHELL \u00a7 Specify the shell to generate completion for, e.g. bash . Defaults to the current shell's name. 9k shorthand \u00a7 9k is a special shorthand to make it easier to configure your build. It's equivalent to bfg9000 configure .","title":"Command-Line Interface"},{"location":"reference/command-line/#command-line-reference","text":"","title":"Command-Line Reference"},{"location":"reference/command-line/#global-options","text":"","title":"Global options"},{"location":"reference/command-line/#help-option","text":"Print a help message and exit. Equivalent to the help subcommand.","title":"-h, --help"},{"location":"reference/command-line/#version","text":"Print the version number and exit.","title":"--version"},{"location":"reference/command-line/#color","text":"Show colored output; WHEN is one of always , never , or auto and defaults to auto (i.e. show colored output when the terminal is a tty). -c is equivalent to --color=always .","title":"-c, --color WHEN"},{"location":"reference/command-line/#warn-once","text":"Only emit a given warning once.","title":"--warn-once"},{"location":"reference/command-line/#sub-commands","text":"","title":"Sub-commands"},{"location":"reference/command-line/#help","text":"Print a help message and exit. If SUBCOMMAND is specified, print help for that subcommand.","title":"bfg9000 help [SUBCOMMAND]"},{"location":"reference/command-line/#configure","text":"Generate the necessary build files to perform actual builds. If DIRECTORY is a source directory (i.e. it contains a build.bfg file), the build files will be created in the current directory. Otherwise, DIRECTORY is treated as the build directory, and bfg9000 will look for a build.bfg file in the current directory.","title":"bfg9000 configure DIRECTORY"},{"location":"reference/command-line/#configure-backend","text":"The kind of build files to generate; one of ninja , make , or msbuild . The default value depends on what build backends you have installed, but if ninja is present on your system, it will be the default.","title":"-B BACKEND, --backend BACKEND"},{"location":"reference/command-line/#configure-toolchain","text":"An optional toolchain file that can be used to easily set all the options required for a certain build.","title":"--toolchain FILE"},{"location":"reference/command-line/#configure-enable-shared","text":"Enable/disable building shared libraries when using library () in your build.bfg files. Defaults to enabled.","title":"--enable-shared, --disable-shared"},{"location":"reference/command-line/#configure-enable-static","text":"Enable/disable building static libraries when using library () in your build.bfg files. Defaults to enabled.","title":"--enable-static, --disable-static"},{"location":"reference/command-line/#configure-enable-compdb","text":"Enable/disable generation of compile_commands.json when generating build files. Defaults to enabled.","title":"--enable-compdb, --disable-compdb"},{"location":"reference/command-line/#configure-package-file","text":"Additional mopack package files to consult when resolving packages.","title":"-p FILE, --package-file FILE"},{"location":"reference/command-line/#configure-package-flag","text":"Additional mopack flags to use when resolving packages.","title":"-P FLAG, --package-flag FLAG"},{"location":"reference/command-line/#configure-no-resolve-packages","text":"Disable resolution of package dependencies via mopack .","title":"--no-resolve-packages"},{"location":"reference/command-line/#configure-prefix","text":"The installation prefix to use when installing built files. On Linux and macOS, this defaults to /usr/local ; on Windows, there is no default (thus, to install built files on Windows, you must either set --prefix or one of the other install path options below).","title":"--prefix PATH"},{"location":"reference/command-line/#configure-exec-prefix","text":"The installation prefix to use when installing architecture-dependent files (e.g. executables). This defaults to the value of --prefix .","title":"--exec-prefix PATH"},{"location":"reference/command-line/#configure-bindir","text":"The installation prefix to use for executables. Defaults to <exec-prefix>/bin on Linux and macOS, and <exec-prefix> on Windows.","title":"--bindir PATH"},{"location":"reference/command-line/#configure-libdir","text":"The installation prefix to use for libraries. Defaults to <exec-prefix>/lib on Linux and macOS, and <exec-prefix> on Windows.","title":"--libdir PATH"},{"location":"reference/command-line/#configure-includedir","text":"The installation prefix to use for headers. Defaults to <prefix>/include on Linux and macOS, and <prefix> on Windows.","title":"--includedir PATH"},{"location":"reference/command-line/#configure-includedir","text":"The installation prefix to use for data files. Defaults to <prefix>/share on Linux and macOS, and <prefix> on Windows.","title":"--includedir PATH"},{"location":"reference/command-line/#configure-mandir","text":"The installation prefix to use for man pages. Defaults to <datadir>/man .","title":"--mandir PATH"},{"location":"reference/command-line/#configure-into","text":"Generate the necessary build files (as with bfg9000 configure ) to perform actual builds from a build.bfg file in SRCDIR , and place them in BUILDDIR .","title":"bfg9000 configure-into SRCDIR BUILDDIR"},{"location":"reference/command-line/#refresh","text":"Regenerate an existing set of build files in BUILDDIR needed to perform actual builds. This is run automatically if bfg9000 determines that the build files are out of date.","title":"bfg9000 refresh [BUILDDIR]"},{"location":"reference/command-line/#env","text":"Print the environment variables stored by the build configuration in BUILDDIR .","title":"bfg9000 env [BUILDDIR]"},{"location":"reference/command-line/#env-unique","text":"Only show environment variables that differ from the current environment.","title":"-u, --unique"},{"location":"reference/command-line/#run","text":"Run an arbitrary COMMAND with the environment variables set for the current build.","title":"bfg9000 run COMMAND"},{"location":"reference/command-line/#run-initial","text":"Use the initial environment variables, before any modification by toolchain files.","title":"-I, --initial"},{"location":"reference/command-line/#run-builddir","text":"Set the build directory to pull environment variable state from.","title":"-B BUILDDIR, --builddir BUILDDIR"},{"location":"reference/command-line/#generate-completion","text":"Generate shell-completion functions for bfg9000 and write them to standard output. This requires the Python package shtab .","title":"bfg9000 generate-completion"},{"location":"reference/command-line/#generate-completion-program","text":"Specify the program to generate completion for: bfg9000 (the default) or 9k .","title":"-p PROGRAM, --program PROGRAM"},{"location":"reference/command-line/#generate-completion-shell","text":"Specify the shell to generate completion for, e.g. bash . Defaults to the current shell's name.","title":"-s SHELL, --shell SHELL"},{"location":"reference/command-line/#9k-shorthand","text":"9k is a special shorthand to make it easier to configure your build. It's equivalent to bfg9000 configure .","title":"9k shorthand"},{"location":"reference/environment-vars/","text":"Environment Variables \u00a7 bfg9000 reads from a number of environment variables. These are the primary way in which users can customize parts of a specific build, e.g. by changing the tools to use or adding compiler flags. Below is a full list of all the environment variables bfg9000 recognizes. Compilation variables \u00a7 Generic \u00a7 CPPFLAGS \u00a7 Default: none \"C preprocessor flags\"; command line arguments to pass to the compiler when compiling any C-family source file (C, C++, Objective C/C++). C \u00a7 CC \u00a7 Default: cc (POSIX), cl (Windows) The command to use when compiling C source files. Also the command to use with cc-style toolchains when linking object files whose source is in C. If not defined, bfg9000 will try to guess the command to use by checking $OBJC , $CXX , and $OBJCXX , in that order. CFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any C source file. C++ \u00a7 CXX \u00a7 Default: c++ (POSIX), cl (Windows) The command to use when compiling C++ source files. Also the command to use with cc-style toolchains when linking object files whose source is in C++. If not defined, bfg9000 will try to guess the command to use by checking $OBJCXX , $CC , and $OBJC , in that order. CXXFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any C++ source file. Fortran \u00a7 FC \u00a7 Default: gfortran The command to use when compiling Fortran source files. Also the command to use when linking object files whose source is in Fortran. FFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any Fortran source file. Java \u00a7 JAVAC \u00a7 Default: javac The command to use when compiling Java source files. JAVAFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any Java source file. Lex \u00a7 LEX \u00a7 Default: lex The command to use when building Lex source files. LFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when building any Lex source file. Objective C \u00a7 OBJC \u00a7 Default: cc The command to use when compiling Objective C source files. Also the command to use with cc-style toolchains when linking object files whose source is in Objective C. If not defined, bfg9000 will try to guess the command to use by checking $CC , $OBJCXX , and $CXX , in that order. OBJCFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any Objective C source file. Objective C++ \u00a7 OBJCXX \u00a7 Default: c++ The command to use when compiling Objective C++ source files. Also the command to use with cc-style toolchains when linking object files whose source is in Objective C++. If not defined, bfg9000 will try to guess the command to use by checking $CXX , $OBJC , and $CC , in that order. OBJCXXFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any Objective C++ source file. Qt MOC \u00a7 MOC \u00a7 Default: moc The command to use when processing Qt meta-object macros. MOCFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when processing Qt meta-object macros. Qt QRC \u00a7 RCC \u00a7 Default: rcc The command to use when building Qt .qrc files. RCCFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when building Qt .qrc files. Qt UI \u00a7 UIC \u00a7 Default: uic The command to use when building Qt .ui files. UICFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when building Qt .ui files. macros. Scala \u00a7 SCALAC \u00a7 Default: scalac The command to use when compiling Scala source files. SCALAFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any Scala source file. Windows resource files \u00a7 RC \u00a7 Default: windres (POSIX), rc (Windows) The command to use when compiling Windows resource ( .rc ) files. RCFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any Windows resource file. Yacc \u00a7 YACC \u00a7 Default: yacc The command to use when building Yacc source files. YFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when building any Yacc source file. Linking variables \u00a7 Static linking \u00a7 AR \u00a7 Default: ar (POSIX), lib (Windows) The command to use when creating (native) static libraries from object files (typically ar on POSIX and lib on Windows). ARFLAGS \u00a7 Default: cru (POSIX) The arguments to pass to the static library builder (specified in $AR ) for native libraries. JAR \u00a7 Default: jar The command to use when creating .jar files for JVM-based binaries. JARFLAGS \u00a7 Default: cfm The arugments to pass to the JAR builders when creating .jar files. Dynamic linking \u00a7 LD \u00a7 Default: none (POSIX), link (Windows) The command to use when linking shared libraries; when using a cc-like builder, this will be processed to infer the appropriate -fuse-ld flag for the linker. LDFLAGS \u00a7 Default: none Command line arguments to pass to the linker when linking an executable or shared library. LDLIBS \u00a7 Default: none Additional libraries to link into an executable or shared library. This is mainly useful for cases where a system library (e.g. the C++ Standard Library implementation) requires another library to be explicitly linked with it. Execution variables \u00a7 JAVACMD \u00a7 Default: java The command to use when running Java .class files or .jar s. (Does not apply when building with GCJ.) LUA \u00a7 Default: lua The command to use when running Lua scripts. PERL \u00a7 Default: perl The command to use when running Perl scripts. PYTHON \u00a7 Default: sys.executable The command to use when running Python scripts. By default, this is the interpreter used to run bfg9000. RUBY \u00a7 Default: ruby The command to use when running Ruby scripts. SCALACMD \u00a7 Default: scala The command to use when running Scala .class files or .jar s. Packaging variables \u00a7 CLASSPATH \u00a7 Default: none A list of additional directories to search for Java class files. On POSIX systems, this is delimited by : ; on Windows, by ; . CPATH \u00a7 Default: none A list of additional directories to search for headers. On POSIX systems, this is delimited by : ; on Windows, by ; . INCLUDE \u00a7 Default: none MSVC-only . A list of directories to search for headers, delimited by ; . LIB \u00a7 Default: none MSVC-only . A list of directories to search for system libraries , delimited by ; . LIBRARY_PATH \u00a7 Default: none A list of additional directories to search for system libraries . On POSIX systems, this is delimited by : ; on Windows, by ; . MOPACK \u00a7 Default: mopack The command to use when resolving package dependencies via mopack . PATH \u00a7 Default: none A list of directories to search for system executables . On POSIX systems, this is delimited by : ; on Windows, by ; . PATHEXT \u00a7 Default: none Windows-only . A list of valid extensions for executable files under Windows, separated by ; . PKG_CONFIG \u00a7 Default: pkg-config The command to use when fetching pkg-config package information. Command variables \u00a7 BFG9000 \u00a7 Default: /path/to/bfg9000 The command to use when executing bfg9000 (e.g. when regenerating the build scripts because the list of source files has changed). This should only be necessary if you run bfg9000 from a wrapper script. CP \u00a7 Default: cp -f (POSIX), cmd /c copy (Windows) The command to use when creating symlinks. DEPFIXER \u00a7 Default: /path/to/bfg9000-depfixer The command to use when fixing up depfiles generated by your compiler for the Make backend. In general, you shouldn't need to touch this. DOPPEL \u00a7 Default: doppel The command to use when installing files and building source distributions. For more information about doppel, see its documentation . GZIP \u00a7 Default: gzip The command to use when gzipping files. HARDLINK \u00a7 Default: ln -f (POSIX), cmd /c mklink /H (Windows) The command to use when creating hard links. INSTALL_NAME_TOOL \u00a7 Default: install_name_tool Darwin-only . The command to use when modifying the paths of the shared libraries linked to during installation. MKDIR_P \u00a7 Default: mkdir -p The command to use when making a directory tree. This is used both for installing whole directories of files and for creating build directories under the Make backend. PATCHELF \u00a7 Default: patchelf Linux-only . The command to use when patching an ELF file's rpath for installation. RCCDEP \u00a7 Default: /path/to/bfg9000-rccdep The command to use when generating depfiles for Qt's rcc tool. In general, you shouldn't need to touch this. SETENV \u00a7 Default: /path/to/bfg9000-setenv Windows-only . The command to use when setting temporary environment variables, similar to the POSIX env command. This is used when setting environment variables for tests. SYMLINK \u00a7 Default: ln -sf (POSIX), cmd /c mklink (Windows) The command to use when creating symlinks. System variables \u00a7 CLICOLOR \u00a7 Default: none If set to 0 , disable colors in terminal output, overriding the --color option and tty detection. If set to non-zero, enable colors if outputting to a tty. CLICOLOR_FORCE \u00a7 Default: none If set to non-zero, enable colors in the terminal output regardless of whether the destination is a tty. This overrides $CLICOLOR . DESTDIR \u00a7 Default: none A directory to prepend to the install location for the project, used in performing staged installs. For more information, see the GNU coding standards . On Windows, this can be used so long as the installation prefixes are drive-relative (e.g. \\path\\to\\install ). PLATFORM \u00a7 Default: Win32 Windows-only . The platform type to use when generating MSBuild files. VCTOOLSVERSION \u00a7 Default: $VISUALSTUDIOVERSION Windows-only . The version of the Visual C++ tools to target when generating MSBuild files. VISUALSTUDIOVERSION \u00a7 Default: 14.0 Windows-only . The version of Visual Studio to target when generating MSBuild files. VSCMD_ARG_VCVARS_VER \u00a7 Default: v140 Windows-only . The version of the platform toolset to target when generating MSBuild files. If not specified, the value will be inferred from $VCTOOLSVERSION . WINDOWSSDKVERSION \u00a7 Default: none Windows-only . The version of the Windows SDK to target when generating MSBuild files.","title":"Environment Variables"},{"location":"reference/environment-vars/#environment-variables","text":"bfg9000 reads from a number of environment variables. These are the primary way in which users can customize parts of a specific build, e.g. by changing the tools to use or adding compiler flags. Below is a full list of all the environment variables bfg9000 recognizes.","title":"Environment Variables"},{"location":"reference/environment-vars/#compilation-variables","text":"","title":"Compilation variables"},{"location":"reference/environment-vars/#generic","text":"","title":"Generic"},{"location":"reference/environment-vars/#cppflags","text":"Default: none \"C preprocessor flags\"; command line arguments to pass to the compiler when compiling any C-family source file (C, C++, Objective C/C++).","title":"CPPFLAGS"},{"location":"reference/environment-vars/#c","text":"","title":"C"},{"location":"reference/environment-vars/#cc","text":"Default: cc (POSIX), cl (Windows) The command to use when compiling C source files. Also the command to use with cc-style toolchains when linking object files whose source is in C. If not defined, bfg9000 will try to guess the command to use by checking $OBJC , $CXX , and $OBJCXX , in that order.","title":"CC"},{"location":"reference/environment-vars/#cflags","text":"Default: none Command line arguments to pass to the compiler when compiling any C source file.","title":"CFLAGS"},{"location":"reference/environment-vars/#c_1","text":"","title":"C++"},{"location":"reference/environment-vars/#cxx","text":"Default: c++ (POSIX), cl (Windows) The command to use when compiling C++ source files. Also the command to use with cc-style toolchains when linking object files whose source is in C++. If not defined, bfg9000 will try to guess the command to use by checking $OBJCXX , $CC , and $OBJC , in that order.","title":"CXX"},{"location":"reference/environment-vars/#cxxflags","text":"Default: none Command line arguments to pass to the compiler when compiling any C++ source file.","title":"CXXFLAGS"},{"location":"reference/environment-vars/#fortran","text":"","title":"Fortran"},{"location":"reference/environment-vars/#fc","text":"Default: gfortran The command to use when compiling Fortran source files. Also the command to use when linking object files whose source is in Fortran.","title":"FC"},{"location":"reference/environment-vars/#fflags","text":"Default: none Command line arguments to pass to the compiler when compiling any Fortran source file.","title":"FFLAGS"},{"location":"reference/environment-vars/#java","text":"","title":"Java"},{"location":"reference/environment-vars/#javac","text":"Default: javac The command to use when compiling Java source files.","title":"JAVAC"},{"location":"reference/environment-vars/#javaflags","text":"Default: none Command line arguments to pass to the compiler when compiling any Java source file.","title":"JAVAFLAGS"},{"location":"reference/environment-vars/#lex","text":"","title":"Lex"},{"location":"reference/environment-vars/#lex_1","text":"Default: lex The command to use when building Lex source files.","title":"LEX"},{"location":"reference/environment-vars/#lflags","text":"Default: none Command line arguments to pass to the compiler when building any Lex source file.","title":"LFLAGS"},{"location":"reference/environment-vars/#objective-c","text":"","title":"Objective C"},{"location":"reference/environment-vars/#objc","text":"Default: cc The command to use when compiling Objective C source files. Also the command to use with cc-style toolchains when linking object files whose source is in Objective C. If not defined, bfg9000 will try to guess the command to use by checking $CC , $OBJCXX , and $CXX , in that order.","title":"OBJC"},{"location":"reference/environment-vars/#objcflags","text":"Default: none Command line arguments to pass to the compiler when compiling any Objective C source file.","title":"OBJCFLAGS"},{"location":"reference/environment-vars/#objective-c_1","text":"","title":"Objective C++"},{"location":"reference/environment-vars/#objcxx","text":"Default: c++ The command to use when compiling Objective C++ source files. Also the command to use with cc-style toolchains when linking object files whose source is in Objective C++. If not defined, bfg9000 will try to guess the command to use by checking $CXX , $OBJC , and $CC , in that order.","title":"OBJCXX"},{"location":"reference/environment-vars/#objcxxflags","text":"Default: none Command line arguments to pass to the compiler when compiling any Objective C++ source file.","title":"OBJCXXFLAGS"},{"location":"reference/environment-vars/#qt-moc","text":"","title":"Qt MOC"},{"location":"reference/environment-vars/#moc","text":"Default: moc The command to use when processing Qt meta-object macros.","title":"MOC"},{"location":"reference/environment-vars/#mocflags","text":"Default: none Command line arguments to pass to the compiler when processing Qt meta-object macros.","title":"MOCFLAGS"},{"location":"reference/environment-vars/#qt-qrc","text":"","title":"Qt QRC"},{"location":"reference/environment-vars/#rcc","text":"Default: rcc The command to use when building Qt .qrc files.","title":"RCC"},{"location":"reference/environment-vars/#rccflags","text":"Default: none Command line arguments to pass to the compiler when building Qt .qrc files.","title":"RCCFLAGS"},{"location":"reference/environment-vars/#qt-ui","text":"","title":"Qt UI"},{"location":"reference/environment-vars/#uic","text":"Default: uic The command to use when building Qt .ui files.","title":"UIC"},{"location":"reference/environment-vars/#uicflags","text":"Default: none Command line arguments to pass to the compiler when building Qt .ui files. macros.","title":"UICFLAGS"},{"location":"reference/environment-vars/#scala","text":"","title":"Scala"},{"location":"reference/environment-vars/#scalac","text":"Default: scalac The command to use when compiling Scala source files.","title":"SCALAC"},{"location":"reference/environment-vars/#scalaflags","text":"Default: none Command line arguments to pass to the compiler when compiling any Scala source file.","title":"SCALAFLAGS"},{"location":"reference/environment-vars/#windows-resource-files","text":"","title":"Windows resource files"},{"location":"reference/environment-vars/#rc","text":"Default: windres (POSIX), rc (Windows) The command to use when compiling Windows resource ( .rc ) files.","title":"RC"},{"location":"reference/environment-vars/#rcflags","text":"Default: none Command line arguments to pass to the compiler when compiling any Windows resource file.","title":"RCFLAGS"},{"location":"reference/environment-vars/#yacc","text":"","title":"Yacc"},{"location":"reference/environment-vars/#yacc_1","text":"Default: yacc The command to use when building Yacc source files.","title":"YACC"},{"location":"reference/environment-vars/#yflags","text":"Default: none Command line arguments to pass to the compiler when building any Yacc source file.","title":"YFLAGS"},{"location":"reference/environment-vars/#linking-variables","text":"","title":"Linking variables"},{"location":"reference/environment-vars/#static-linking","text":"","title":"Static linking"},{"location":"reference/environment-vars/#ar","text":"Default: ar (POSIX), lib (Windows) The command to use when creating (native) static libraries from object files (typically ar on POSIX and lib on Windows).","title":"AR"},{"location":"reference/environment-vars/#arflags","text":"Default: cru (POSIX) The arguments to pass to the static library builder (specified in $AR ) for native libraries.","title":"ARFLAGS"},{"location":"reference/environment-vars/#jar","text":"Default: jar The command to use when creating .jar files for JVM-based binaries.","title":"JAR"},{"location":"reference/environment-vars/#jarflags","text":"Default: cfm The arugments to pass to the JAR builders when creating .jar files.","title":"JARFLAGS"},{"location":"reference/environment-vars/#dynamic-linking","text":"","title":"Dynamic linking"},{"location":"reference/environment-vars/#ld","text":"Default: none (POSIX), link (Windows) The command to use when linking shared libraries; when using a cc-like builder, this will be processed to infer the appropriate -fuse-ld flag for the linker.","title":"LD"},{"location":"reference/environment-vars/#ldflags","text":"Default: none Command line arguments to pass to the linker when linking an executable or shared library.","title":"LDFLAGS"},{"location":"reference/environment-vars/#ldlibs","text":"Default: none Additional libraries to link into an executable or shared library. This is mainly useful for cases where a system library (e.g. the C++ Standard Library implementation) requires another library to be explicitly linked with it.","title":"LDLIBS"},{"location":"reference/environment-vars/#execution-variables","text":"","title":"Execution variables"},{"location":"reference/environment-vars/#javacmd","text":"Default: java The command to use when running Java .class files or .jar s. (Does not apply when building with GCJ.)","title":"JAVACMD"},{"location":"reference/environment-vars/#lua","text":"Default: lua The command to use when running Lua scripts.","title":"LUA"},{"location":"reference/environment-vars/#perl","text":"Default: perl The command to use when running Perl scripts.","title":"PERL"},{"location":"reference/environment-vars/#python","text":"Default: sys.executable The command to use when running Python scripts. By default, this is the interpreter used to run bfg9000.","title":"PYTHON"},{"location":"reference/environment-vars/#ruby","text":"Default: ruby The command to use when running Ruby scripts.","title":"RUBY"},{"location":"reference/environment-vars/#scalacmd","text":"Default: scala The command to use when running Scala .class files or .jar s.","title":"SCALACMD"},{"location":"reference/environment-vars/#packaging-variables","text":"","title":"Packaging variables"},{"location":"reference/environment-vars/#classpath","text":"Default: none A list of additional directories to search for Java class files. On POSIX systems, this is delimited by : ; on Windows, by ; .","title":"CLASSPATH"},{"location":"reference/environment-vars/#cpath","text":"Default: none A list of additional directories to search for headers. On POSIX systems, this is delimited by : ; on Windows, by ; .","title":"CPATH"},{"location":"reference/environment-vars/#include","text":"Default: none MSVC-only . A list of directories to search for headers, delimited by ; .","title":"INCLUDE"},{"location":"reference/environment-vars/#lib","text":"Default: none MSVC-only . A list of directories to search for system libraries , delimited by ; .","title":"LIB"},{"location":"reference/environment-vars/#library_path","text":"Default: none A list of additional directories to search for system libraries . On POSIX systems, this is delimited by : ; on Windows, by ; .","title":"LIBRARY_PATH"},{"location":"reference/environment-vars/#mopack","text":"Default: mopack The command to use when resolving package dependencies via mopack .","title":"MOPACK"},{"location":"reference/environment-vars/#path","text":"Default: none A list of directories to search for system executables . On POSIX systems, this is delimited by : ; on Windows, by ; .","title":"PATH"},{"location":"reference/environment-vars/#pathext","text":"Default: none Windows-only . A list of valid extensions for executable files under Windows, separated by ; .","title":"PATHEXT"},{"location":"reference/environment-vars/#pkg_config","text":"Default: pkg-config The command to use when fetching pkg-config package information.","title":"PKG_CONFIG"},{"location":"reference/environment-vars/#command-variables","text":"","title":"Command variables"},{"location":"reference/environment-vars/#bfg9000","text":"Default: /path/to/bfg9000 The command to use when executing bfg9000 (e.g. when regenerating the build scripts because the list of source files has changed). This should only be necessary if you run bfg9000 from a wrapper script.","title":"BFG9000"},{"location":"reference/environment-vars/#cp","text":"Default: cp -f (POSIX), cmd /c copy (Windows) The command to use when creating symlinks.","title":"CP"},{"location":"reference/environment-vars/#depfixer","text":"Default: /path/to/bfg9000-depfixer The command to use when fixing up depfiles generated by your compiler for the Make backend. In general, you shouldn't need to touch this.","title":"DEPFIXER"},{"location":"reference/environment-vars/#doppel","text":"Default: doppel The command to use when installing files and building source distributions. For more information about doppel, see its documentation .","title":"DOPPEL"},{"location":"reference/environment-vars/#gzip","text":"Default: gzip The command to use when gzipping files.","title":"GZIP"},{"location":"reference/environment-vars/#hardlink","text":"Default: ln -f (POSIX), cmd /c mklink /H (Windows) The command to use when creating hard links.","title":"HARDLINK"},{"location":"reference/environment-vars/#install_name_tool","text":"Default: install_name_tool Darwin-only . The command to use when modifying the paths of the shared libraries linked to during installation.","title":"INSTALL_NAME_TOOL"},{"location":"reference/environment-vars/#mkdir_p","text":"Default: mkdir -p The command to use when making a directory tree. This is used both for installing whole directories of files and for creating build directories under the Make backend.","title":"MKDIR_P"},{"location":"reference/environment-vars/#patchelf","text":"Default: patchelf Linux-only . The command to use when patching an ELF file's rpath for installation.","title":"PATCHELF"},{"location":"reference/environment-vars/#rccdep","text":"Default: /path/to/bfg9000-rccdep The command to use when generating depfiles for Qt's rcc tool. In general, you shouldn't need to touch this.","title":"RCCDEP"},{"location":"reference/environment-vars/#setenv","text":"Default: /path/to/bfg9000-setenv Windows-only . The command to use when setting temporary environment variables, similar to the POSIX env command. This is used when setting environment variables for tests.","title":"SETENV"},{"location":"reference/environment-vars/#symlink","text":"Default: ln -sf (POSIX), cmd /c mklink (Windows) The command to use when creating symlinks.","title":"SYMLINK"},{"location":"reference/environment-vars/#system-variables","text":"","title":"System variables"},{"location":"reference/environment-vars/#clicolor","text":"Default: none If set to 0 , disable colors in terminal output, overriding the --color option and tty detection. If set to non-zero, enable colors if outputting to a tty.","title":"CLICOLOR"},{"location":"reference/environment-vars/#clicolor_force","text":"Default: none If set to non-zero, enable colors in the terminal output regardless of whether the destination is a tty. This overrides $CLICOLOR .","title":"CLICOLOR_FORCE"},{"location":"reference/environment-vars/#destdir","text":"Default: none A directory to prepend to the install location for the project, used in performing staged installs. For more information, see the GNU coding standards . On Windows, this can be used so long as the installation prefixes are drive-relative (e.g. \\path\\to\\install ).","title":"DESTDIR"},{"location":"reference/environment-vars/#platform","text":"Default: Win32 Windows-only . The platform type to use when generating MSBuild files.","title":"PLATFORM"},{"location":"reference/environment-vars/#vctoolsversion","text":"Default: $VISUALSTUDIOVERSION Windows-only . The version of the Visual C++ tools to target when generating MSBuild files.","title":"VCTOOLSVERSION"},{"location":"reference/environment-vars/#visualstudioversion","text":"Default: 14.0 Windows-only . The version of Visual Studio to target when generating MSBuild files.","title":"VISUALSTUDIOVERSION"},{"location":"reference/environment-vars/#vscmd_arg_vcvars_ver","text":"Default: v140 Windows-only . The version of the platform toolset to target when generating MSBuild files. If not specified, the value will be inferred from $VCTOOLSVERSION .","title":"VSCMD_ARG_VCVARS_VER"},{"location":"reference/environment-vars/#windowssdkversion","text":"Default: none Windows-only . The version of the Windows SDK to target when generating MSBuild files.","title":"WINDOWSSDKVERSION"},{"location":"reference/languages/","text":"Supported Languages \u00a7 bfg9000 supports the following languages. In the tables below, you'll find the language name as it's used internally (which can be passed via the lang parameter where applicable), the automatically-detected file extensions, and the build steps that can be used with that language. C \u00a7 Name 'c' Source extensions .c Header extensions .h Build steps object_file , executable , shared_library , static_library C++ \u00a7 Name 'c++' Source extensions .cpp , .cc , .cp , .cxx , .CPP , .c++ , .C Header extensions .hpp , .hh , .hp , .hxx , .HPP , .h++ , .H Build steps object_file , executable , shared_library , static_library Objective C \u00a7 Name 'objc' Source extensions .m Build steps object_file , executable , shared_library , static_library Objective C++ \u00a7 Name 'objc++' Source extensions .mm , .M Build steps object_file , executable , shared_library , static_library Fortran 77 \u00a7 Name 'f77' Source extensions .f , .for , .ftn Build steps object_file , executable , shared_library , static_library Fortran 95 \u00a7 Name 'f95' Source extensions .f90 , .f95 , .f03 , .f08 Build steps object_file , executable , shared_library , static_library Notes Modules not supported Java \u00a7 Name 'java' Source extensions .java Build steps object_file , executable , shared_library , static_library (GCJ only) Scala \u00a7 Name 'scala' Source extensions .scala Build steps object_file , executable , shared_library Lex \u00a7 Name 'lex' Source extensions .l Build steps generated_source Yacc \u00a7 Name 'yacc' Source extensions .y Build steps generated_source Windows Resource \u00a7 Name 'rc' Source extensions .rc Build steps object_file Qt MOC \u00a7 Name 'qtmoc' Source extensions none Build steps generated_source Qt Resource \u00a7 Name 'qrc' Source extensions .qrc Build steps generated_source Qt UI \u00a7 Name 'qtui' Source extensions .ui Build steps generated_source Lua \u00a7 Name 'lua' Source extensions .lua Build steps none Perl \u00a7 Name 'perl' Source extensions .pl Build steps none Python \u00a7 Name 'python' Source extensions .py Build steps none Ruby \u00a7 Name 'ruby' Source extensions .rb Build steps none","title":"Supported Languages"},{"location":"reference/languages/#supported-languages","text":"bfg9000 supports the following languages. In the tables below, you'll find the language name as it's used internally (which can be passed via the lang parameter where applicable), the automatically-detected file extensions, and the build steps that can be used with that language.","title":"Supported Languages"},{"location":"reference/languages/#c","text":"Name 'c' Source extensions .c Header extensions .h Build steps object_file , executable , shared_library , static_library","title":"C"},{"location":"reference/languages/#c_1","text":"Name 'c++' Source extensions .cpp , .cc , .cp , .cxx , .CPP , .c++ , .C Header extensions .hpp , .hh , .hp , .hxx , .HPP , .h++ , .H Build steps object_file , executable , shared_library , static_library","title":"C++"},{"location":"reference/languages/#objective-c","text":"Name 'objc' Source extensions .m Build steps object_file , executable , shared_library , static_library","title":"Objective C"},{"location":"reference/languages/#objective-c_1","text":"Name 'objc++' Source extensions .mm , .M Build steps object_file , executable , shared_library , static_library","title":"Objective C++"},{"location":"reference/languages/#fortran-77","text":"Name 'f77' Source extensions .f , .for , .ftn Build steps object_file , executable , shared_library , static_library","title":"Fortran 77"},{"location":"reference/languages/#fortran-95","text":"Name 'f95' Source extensions .f90 , .f95 , .f03 , .f08 Build steps object_file , executable , shared_library , static_library Notes Modules not supported","title":"Fortran 95"},{"location":"reference/languages/#java","text":"Name 'java' Source extensions .java Build steps object_file , executable , shared_library , static_library (GCJ only)","title":"Java"},{"location":"reference/languages/#scala","text":"Name 'scala' Source extensions .scala Build steps object_file , executable , shared_library","title":"Scala"},{"location":"reference/languages/#lex","text":"Name 'lex' Source extensions .l Build steps generated_source","title":"Lex"},{"location":"reference/languages/#yacc","text":"Name 'yacc' Source extensions .y Build steps generated_source","title":"Yacc"},{"location":"reference/languages/#windows-resource","text":"Name 'rc' Source extensions .rc Build steps object_file","title":"Windows Resource"},{"location":"reference/languages/#qt-moc","text":"Name 'qtmoc' Source extensions none Build steps generated_source","title":"Qt MOC"},{"location":"reference/languages/#qt-resource","text":"Name 'qrc' Source extensions .qrc Build steps generated_source","title":"Qt Resource"},{"location":"reference/languages/#qt-ui","text":"Name 'qtui' Source extensions .ui Build steps generated_source","title":"Qt UI"},{"location":"reference/languages/#lua","text":"Name 'lua' Source extensions .lua Build steps none","title":"Lua"},{"location":"reference/languages/#perl","text":"Name 'perl' Source extensions .pl Build steps none","title":"Perl"},{"location":"reference/languages/#python","text":"Name 'python' Source extensions .py Build steps none","title":"Python"},{"location":"reference/languages/#ruby","text":"Name 'ruby' Source extensions .rb Build steps none","title":"Ruby"},{"location":"user/building/","text":"Building With bfg9000 \u00a7 Like some other tools (e.g. CMake or autotools ), bfg9000 isn't actually a build system; it's a build configuration system or, if you prefer, a meta-build system . That is, bfg9000 builds build files which you then use to run your actual builds. Your first build \u00a7 Invoking bfg9000 is simple. Assuming you have an existing project that uses bfg9000, just call bfg9000 configure builddir and it will generate the final build script ( build.ninja in this case) in builddir to use for building your project: $ cd /path/to/src/ $ bfg9000 configure builddir/ $ cd builddir/ $ ninja Since the configure command is easily the most common thing to run when using bfg9000, you can use the following shorthand instead of bfg9000 configure builddir/ : $ 9k builddir/ Note On Windows, using bfg9000 requires a bit more care. Since the MSVC tools aren't in the $PATH by default, you can't just open any command prompt. You need to pick the correct prompt. Thankfully, Visual Studio provides Start Menu items such as \"VS2015 Developer Command Prompt\". These add the appropiate directories to the $PATH , allowing you to use whichever version of the MSVC tools that you'd like. Build directories \u00a7 You might have noticed above that build.ninja was placed in a separate directory. This is because bfg9000 exclusively uses out-of-tree builds ; that is, the build directory must be different from the source directory. While slightly more inconvenient for one-off builds (users will have to cd into another directory to start the build), the benefits are significant. First, it ensures that cleaning a build is trivial: just remove the build directory. Second, simplifies building in multiple configurations, a very useful feature for development; you can easily have debug and optimized builds sitting side-by-side. In our example above, we specified the build directory to place the final build files. However, you can also run bfg9000 from the build directory, in which case you'd run bfg9000 configure srcdir/ (or, equivalently, 9k srcdir/ ). If neither the source nor build directories are your current working directory, you can run: $ bfg9000 configure-into srcdir/ builddir/ Selecting a backend \u00a7 By default, bfg9000 tries to use the most appropriate build backend for your system. In descending order, bfg prefers ninja , make , and msbuild . If one of these isn't installed, it will try the next best option. However, you can explicitly select a backend with the --backend option. For instance, to build a Makefile even if Ninja is installed: $ bfg9000 configure builddir/ --backend=make For a complete description of the available command-line options for bfg9000, see the Command-line Reference chapter. Setting build options \u00a7 Many options for building can be set via the environment. These generally follow the UNIX naming conventions, so you can use, say, $CXX to change the C++ compiler that bfg9000 uses. For a full listing of the recognized environment variables, see the Environment Variables chapter. Using toolchain files \u00a7 In order to simplify setting up all the myriad options required for certain builds (and to share those settings with others), bfg9000 allows users to use toolchain files that define all this. To use an existing toolchain file, just use the --toolchain option during configuration: $ bfg9000 configure builddir/ --toolchain my_toolchain.bfg Writing a toolchain file \u00a7 Toolchain files, like other .bfg files, are just Python scripts with some extra built-in functions. However, unlike other .bfg files, toolchain files have a few restrictions: file access and import statements are disabled. Since many users will copy toolchain files from other sources to build for a specific target, this helps reduce the potential for unwanted things from happening while building your software. Generally, toolchain files will set up relevant compilers, compilation options, and other aspects of the environment. These settings are then forwarded on to the build.bfg script proper. Below is a simple toolchain file that demonstrates some common settings: target_platform('windows', 'x86_64') compiler('x86_64-w64-mingw32-g++-win32', 'c++') compile_options(['-Wall'], 'c++') For more information on the available builtins, see the reference guide . Installing your software \u00a7 After building your software, you may wish to install it to another directory on your system. You can do this by running: $ ninja install Similarly, you can run ninja uninstall to uninstall the files from their install location. Of course, if you're using the Make backend, you'd run make install / make uninstall instead. Warning The MSBuild backend doesn't currently support this command. Install locations \u00a7 By default, bfg9000 will install them into the appropriate place for your platform (e.g. /usr/local/bin for exectuables on POSIX systems). However, you can specify where you'd like to install your project when invoking bfg9000. To change the installation prefix ( /usr/local on POSIX), just specify --prefix /path/to/prefix when running bfg9000. You can also specify the binary, library, and include directories individually, using --bindir , --libdir , and --includedir , respectively. You can additionally specify the $DESTDIR environment variable to perform a staged installation (useful when creating a binary package, for example). For more information about $DESTDIR , see the GNU coding standards . Note On Windows, $DESTDIR can be used provided the installation prefixes are drive-relative (e.g. \\path\\to\\install , not C:\\path\\to\\install ). Distributing your source \u00a7 Once you're ready to release your software, you'll want to provide a source distribution. You can't just archive the entire source directory, since it'll include things that don't belong like .gitignore . Instead, you should run: $ ninja dist (Of course, you should run make dist for the Make backend.) This will produce a tar.gz file containing all the source files necessary for building your project. If you'd like to specify another file format, you can use one of the following targets: dist-gzip , dist-bzip2 , or dist-zip . Warning The MSBuild backend doesn't currently support this command.","title":"Building with bfg9000"},{"location":"user/building/#building-with-bfg9000","text":"Like some other tools (e.g. CMake or autotools ), bfg9000 isn't actually a build system; it's a build configuration system or, if you prefer, a meta-build system . That is, bfg9000 builds build files which you then use to run your actual builds.","title":"Building With bfg9000"},{"location":"user/building/#your-first-build","text":"Invoking bfg9000 is simple. Assuming you have an existing project that uses bfg9000, just call bfg9000 configure builddir and it will generate the final build script ( build.ninja in this case) in builddir to use for building your project: $ cd /path/to/src/ $ bfg9000 configure builddir/ $ cd builddir/ $ ninja Since the configure command is easily the most common thing to run when using bfg9000, you can use the following shorthand instead of bfg9000 configure builddir/ : $ 9k builddir/ Note On Windows, using bfg9000 requires a bit more care. Since the MSVC tools aren't in the $PATH by default, you can't just open any command prompt. You need to pick the correct prompt. Thankfully, Visual Studio provides Start Menu items such as \"VS2015 Developer Command Prompt\". These add the appropiate directories to the $PATH , allowing you to use whichever version of the MSVC tools that you'd like.","title":"Your first build"},{"location":"user/building/#build-directories","text":"You might have noticed above that build.ninja was placed in a separate directory. This is because bfg9000 exclusively uses out-of-tree builds ; that is, the build directory must be different from the source directory. While slightly more inconvenient for one-off builds (users will have to cd into another directory to start the build), the benefits are significant. First, it ensures that cleaning a build is trivial: just remove the build directory. Second, simplifies building in multiple configurations, a very useful feature for development; you can easily have debug and optimized builds sitting side-by-side. In our example above, we specified the build directory to place the final build files. However, you can also run bfg9000 from the build directory, in which case you'd run bfg9000 configure srcdir/ (or, equivalently, 9k srcdir/ ). If neither the source nor build directories are your current working directory, you can run: $ bfg9000 configure-into srcdir/ builddir/","title":"Build directories"},{"location":"user/building/#selecting-a-backend","text":"By default, bfg9000 tries to use the most appropriate build backend for your system. In descending order, bfg prefers ninja , make , and msbuild . If one of these isn't installed, it will try the next best option. However, you can explicitly select a backend with the --backend option. For instance, to build a Makefile even if Ninja is installed: $ bfg9000 configure builddir/ --backend=make For a complete description of the available command-line options for bfg9000, see the Command-line Reference chapter.","title":"Selecting a backend"},{"location":"user/building/#setting-build-options","text":"Many options for building can be set via the environment. These generally follow the UNIX naming conventions, so you can use, say, $CXX to change the C++ compiler that bfg9000 uses. For a full listing of the recognized environment variables, see the Environment Variables chapter.","title":"Setting build options"},{"location":"user/building/#using-toolchain-files","text":"In order to simplify setting up all the myriad options required for certain builds (and to share those settings with others), bfg9000 allows users to use toolchain files that define all this. To use an existing toolchain file, just use the --toolchain option during configuration: $ bfg9000 configure builddir/ --toolchain my_toolchain.bfg","title":"Using toolchain files"},{"location":"user/building/#writing-a-toolchain-file","text":"Toolchain files, like other .bfg files, are just Python scripts with some extra built-in functions. However, unlike other .bfg files, toolchain files have a few restrictions: file access and import statements are disabled. Since many users will copy toolchain files from other sources to build for a specific target, this helps reduce the potential for unwanted things from happening while building your software. Generally, toolchain files will set up relevant compilers, compilation options, and other aspects of the environment. These settings are then forwarded on to the build.bfg script proper. Below is a simple toolchain file that demonstrates some common settings: target_platform('windows', 'x86_64') compiler('x86_64-w64-mingw32-g++-win32', 'c++') compile_options(['-Wall'], 'c++') For more information on the available builtins, see the reference guide .","title":"Writing a toolchain file"},{"location":"user/building/#installing-your-software","text":"After building your software, you may wish to install it to another directory on your system. You can do this by running: $ ninja install Similarly, you can run ninja uninstall to uninstall the files from their install location. Of course, if you're using the Make backend, you'd run make install / make uninstall instead. Warning The MSBuild backend doesn't currently support this command.","title":"Installing your software"},{"location":"user/building/#install-locations","text":"By default, bfg9000 will install them into the appropriate place for your platform (e.g. /usr/local/bin for exectuables on POSIX systems). However, you can specify where you'd like to install your project when invoking bfg9000. To change the installation prefix ( /usr/local on POSIX), just specify --prefix /path/to/prefix when running bfg9000. You can also specify the binary, library, and include directories individually, using --bindir , --libdir , and --includedir , respectively. You can additionally specify the $DESTDIR environment variable to perform a staged installation (useful when creating a binary package, for example). For more information about $DESTDIR , see the GNU coding standards . Note On Windows, $DESTDIR can be used provided the installation prefixes are drive-relative (e.g. \\path\\to\\install , not C:\\path\\to\\install ).","title":"Install locations"},{"location":"user/building/#distributing-your-source","text":"Once you're ready to release your software, you'll want to provide a source distribution. You can't just archive the entire source directory, since it'll include things that don't belong like .gitignore . Instead, you should run: $ ninja dist (Of course, you should run make dist for the Make backend.) This will produce a tar.gz file containing all the source files necessary for building your project. If you'd like to specify another file format, you can use one of the following targets: dist-gzip , dist-bzip2 , or dist-zip . Warning The MSBuild backend doesn't currently support this command.","title":"Distributing your source"},{"location":"user/features/","text":"Features \u00a7 Supported languages/platforms \u00a7 bfg9000 is designed to work on Linux, OS X, and Windows; other POSIX systems should work as well, but they aren't explicitly supported (if you'd like to help add support for your favorite platform, just file a pull request!). In addition, bfg9000 supports building code written in the following languages: C C++ Fortran Java Objective C/C++ Scala ... and more Finally, bfg supports generating build files for Make , Ninja , and MSBuild , defaulting to Ninja. Rich scripting \u00a7 Since build.bfg (and options.bfg !) files are just Python scripts with some extra builtins, it's possible to use the entirety of the Python ecosystem in your build scripts. This allows you to perform complex operations in your build scripts without having to roll everything yourself or provide a layer of \"glue\" to some external scripts in your build process. Flexible package dependencies \u00a7 bfg9000 integrates with mopack to provide support for getting external package dependencies from multiple sources and allowing people building your project to easily override how packages are found. It's also easy to generate pkg-config .pc files for your own packages to simplify using them elsewhere. Project-defined arguments \u00a7 Projects can specify their own options, complete with help instructions, in the options.bfg , making it easy to help users get your project configured for their system. Semantic options \u00a7 To simplify building your software with different compilers, many common compiler flags can be represented with semantic options . These will then be translated to the appropriate syntax for the selected compiler. Toolchains for cross-compilation \u00a7 When configuring a build, you can take advantage of toolchain files , which specify the necessary settings (e.g. environment variables) for properly building your software, especially useful for cross-compilation configurations. Intelligent rpath support \u00a7 bfg9000 automatically specifies rpaths on platforms that support them (currently Linux and macOS), making it easier to produce correct builds. When building, bfg always produces relative rpaths to allow moving your build directory without breaking things; however, when installing your build, these rpaths are modified to absolute paths (using patchelf on Linux and install_name_tool on macOS). Auto-sudo during installation \u00a7 When installing your builds, the install tool ( doppel ) will automatically request sudo priveleges if the installation directory requires it. This allows you to run ninja install as a non-root user, preventing permissions issues with intermediate files as well as being more secure. pkg-config lookup and generation \u00a7 bfg9000 supports pkg-config both for looking up packages as well as generating .pc files for your own packages.","title":"Features"},{"location":"user/features/#features","text":"","title":"Features"},{"location":"user/features/#supported-languagesplatforms","text":"bfg9000 is designed to work on Linux, OS X, and Windows; other POSIX systems should work as well, but they aren't explicitly supported (if you'd like to help add support for your favorite platform, just file a pull request!). In addition, bfg9000 supports building code written in the following languages: C C++ Fortran Java Objective C/C++ Scala ... and more Finally, bfg supports generating build files for Make , Ninja , and MSBuild , defaulting to Ninja.","title":"Supported languages/platforms"},{"location":"user/features/#rich-scripting","text":"Since build.bfg (and options.bfg !) files are just Python scripts with some extra builtins, it's possible to use the entirety of the Python ecosystem in your build scripts. This allows you to perform complex operations in your build scripts without having to roll everything yourself or provide a layer of \"glue\" to some external scripts in your build process.","title":"Rich scripting"},{"location":"user/features/#flexible-package-dependencies","text":"bfg9000 integrates with mopack to provide support for getting external package dependencies from multiple sources and allowing people building your project to easily override how packages are found. It's also easy to generate pkg-config .pc files for your own packages to simplify using them elsewhere.","title":"Flexible package dependencies"},{"location":"user/features/#project-defined-arguments","text":"Projects can specify their own options, complete with help instructions, in the options.bfg , making it easy to help users get your project configured for their system.","title":"Project-defined arguments"},{"location":"user/features/#semantic-options","text":"To simplify building your software with different compilers, many common compiler flags can be represented with semantic options . These will then be translated to the appropriate syntax for the selected compiler.","title":"Semantic options"},{"location":"user/features/#toolchains-for-cross-compilation","text":"When configuring a build, you can take advantage of toolchain files , which specify the necessary settings (e.g. environment variables) for properly building your software, especially useful for cross-compilation configurations.","title":"Toolchains for cross-compilation"},{"location":"user/features/#intelligent-rpath-support","text":"bfg9000 automatically specifies rpaths on platforms that support them (currently Linux and macOS), making it easier to produce correct builds. When building, bfg always produces relative rpaths to allow moving your build directory without breaking things; however, when installing your build, these rpaths are modified to absolute paths (using patchelf on Linux and install_name_tool on macOS).","title":"Intelligent rpath support"},{"location":"user/features/#auto-sudo-during-installation","text":"When installing your builds, the install tool ( doppel ) will automatically request sudo priveleges if the installation directory requires it. This allows you to run ninja install as a non-root user, preventing permissions issues with intermediate files as well as being more secure.","title":"Auto-sudo during installation"},{"location":"user/features/#pkg-config-lookup-and-generation","text":"bfg9000 supports pkg-config both for looking up packages as well as generating .pc files for your own packages.","title":"pkg-config lookup and generation"},{"location":"user/getting-started/","text":"Getting Started \u00a7 Supported platforms/languages \u00a7 bfg9000 is designed to work on Linux, OS X, and Windows; other POSIX systems should work as well, but they aren't explicitly supported (if you'd like to help add support for your favorite platform, just file a pull request!). In addition, bfg9000 supports building code written in the following languages: C C++ Fortran (partial) Java Objective C/C++ Scala For more details on what you can do with bfg9000, see the features page. Installation \u00a7 bfg9000 uses setuptools , so installation is much the same as any other Python package: $ pip install bfg9000 If you've downloaded bfg already, just run pip install . from the source directory. (Equivalently, you can run python setup.py install .) From there, you can start using bfg to build your software! Note If you're using Ubuntu, you can also install bfg9000 from the following PPA: ppa:jimporter/stable . Once you've installed bfg9000, you might also want to set up shell-completion for it. If you have shtab installed, you can do this with bfg9000 generate-completion , which will print the shell-completion code for your shell to standard output. For more details on how to set this up, consult shtab's documentation . External dependencies \u00a7 In addition to a compiler for your chosen language, bfg9000 expects a few other tools to be installed on your system: pkg-config (or an equivalent tool like [ pkgconf ][pfgconf] patchelf on ELF-based systems (e.g. Linux) Installing MSBuild support \u00a7 Since many users don't need it, MSBuild support is an optional feature. To install all the dependencies required for MSBuild, you can run the following: $ pip install bfg9000[msbuild] Editor integration \u00a7 Since bfg9000 scripts are just Python scripts with some extra built-in functions, it should be easy to get syntax highlighting for bfg9000 scripts in your favorite editor. However, the extra builtins can cause spurious errors if your editor expects to be able to look them up (e.g. via LSP ). A more robust alternative is to treat bfg9000 scripts as a different language. Emacs users can do this by installing the bfg9000-mode package. If you want to treat bfg9000 scripts as bfg9000 when possible, but fall back to Python otherwise, you can insert the following as the first line of your scripts: # -*- mode: python; mode: bfg9000 -*- Emacs (and other editors that understand Emacs' file-local variables) will use the last mode available to the editor.","title":"Getting Started"},{"location":"user/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"user/getting-started/#supported-platformslanguages","text":"bfg9000 is designed to work on Linux, OS X, and Windows; other POSIX systems should work as well, but they aren't explicitly supported (if you'd like to help add support for your favorite platform, just file a pull request!). In addition, bfg9000 supports building code written in the following languages: C C++ Fortran (partial) Java Objective C/C++ Scala For more details on what you can do with bfg9000, see the features page.","title":"Supported platforms/languages"},{"location":"user/getting-started/#installation","text":"bfg9000 uses setuptools , so installation is much the same as any other Python package: $ pip install bfg9000 If you've downloaded bfg already, just run pip install . from the source directory. (Equivalently, you can run python setup.py install .) From there, you can start using bfg to build your software! Note If you're using Ubuntu, you can also install bfg9000 from the following PPA: ppa:jimporter/stable . Once you've installed bfg9000, you might also want to set up shell-completion for it. If you have shtab installed, you can do this with bfg9000 generate-completion , which will print the shell-completion code for your shell to standard output. For more details on how to set this up, consult shtab's documentation .","title":"Installation"},{"location":"user/getting-started/#external-dependencies","text":"In addition to a compiler for your chosen language, bfg9000 expects a few other tools to be installed on your system: pkg-config (or an equivalent tool like [ pkgconf ][pfgconf] patchelf on ELF-based systems (e.g. Linux)","title":"External dependencies"},{"location":"user/getting-started/#installing-msbuild-support","text":"Since many users don't need it, MSBuild support is an optional feature. To install all the dependencies required for MSBuild, you can run the following: $ pip install bfg9000[msbuild]","title":"Installing MSBuild support"},{"location":"user/getting-started/#editor-integration","text":"Since bfg9000 scripts are just Python scripts with some extra built-in functions, it should be easy to get syntax highlighting for bfg9000 scripts in your favorite editor. However, the extra builtins can cause spurious errors if your editor expects to be able to look them up (e.g. via LSP ). A more robust alternative is to treat bfg9000 scripts as a different language. Emacs users can do this by installing the bfg9000-mode package. If you want to treat bfg9000 scripts as bfg9000 when possible, but fall back to Python otherwise, you can insert the following as the first line of your scripts: # -*- mode: python; mode: bfg9000 -*- Emacs (and other editors that understand Emacs' file-local variables) will use the last mode available to the editor.","title":"Editor integration"},{"location":"user/writing/","text":"Writing a Build File \u00a7 bfg9000's build script is called build.bfg and is (usually) placed in the root of your source tree. build.bfg files are just Python scripts with a handful of extra built-in functions to define all the steps for building your software. While bfg9000's goal is to make writing build scripts easy, sometimes complexity is unavoidable. By using a general-purpose language, this complexity can (hopefully!) be managed. Your first build script \u00a7 The simplest build script, compiling a single source file into an executable , is indeed very simple: executable('simple', files=['simple.cpp']) The above is all you need to build your executable for any supported build backend and platform. The output file's name is automatically converted to the appropriate name for the target platform ( 'simple' on Linux and OS X and 'simple.exe' on Windows). Logging messages \u00a7 Sometimes, it can be helpful to display messages to the user when they're building your project. While print , sys.stdout , and the like work, these aren't integrated into bfg9000's logging system. Instead, you can use info() , warning() , or debug() to log your messages: try: pkg = package('optional_dependency') except PackageResolutionError: warning('optional_dependency not found; fancy-feature disabled') Building executables \u00a7 We've already seen how to build simple executables, but build tools aren't much good if that's all they can do! Naturally, it's easy to build an executable from multiple source files (just add more elements to the files argument), but there are plenty of other things you'd probably like to do with your build scripts. Implicit conversions \u00a7 bfg9000 tries its best to make your build scripts easy to read and to minimize verbosity. First, arguments that normally take a list can take a single item instead, e.g. executable('simple', files='simple.cpp') . In addition, bfg9000 will automatically convert a string argument to an object of the appropriate type. In the previous example, 'simple.cpp' is automatically passed to object_files , which in turn converts it to a source_file and generates the appropriate build step. Subdirectories \u00a7 Many projects organize their headers and source files into different directories. For source files, this is easy to handle: just write out the relative path to the file. For header files, you need to let your compiler know where they're located. The header_directory function creates a reference to the directory, which can then be passed to your build function via the include argument: include_dir = header_directory('include') executable('program', files=['src/prog.cpp'], includes=[include_dir]) As noted above, you can also simplify this to: executable('program', files='src/prog.cpp', includes='include') Of course, bfg9000 also allows you to place built files in subdirectories as well. Simply specify the relative path as the name of executable (or whatever type of file you're building). Options \u00a7 Build scripts often need to set options when compiling/linking binaries. Sometimes, these are specific to a single executable in the project, and other times they apply to all the binaries. bfg9000 supports both cases. You can provide options for a single binary with the compile_options and link_options arguments: executable('simple', files=['simple.cpp'], compile_options=['-Wall', '-Werror'], link_options=['-static-libstdc++']) You can also specify global compiler options (on a per-language basis) as well as global linker options : global_options(['-Wall', '-Werror'], lang='c++') global_link_options(['-static-libstdc++']) In addition to passing options as lists as above, you can also pass them as a single string, which will be split according to the rules for sh-style command line arguments. Semantic options \u00a7 Naturally, the interpretations of these options depend on the compiler (or linker!) being used. One method is simply to the kind of compiler being used and supply the appropriate option strings. You can do this by consulting the build's Environment and checking the compiler's flavor . However, it's often better to use semantic options , options that are defined as objects which will automatically be interpreted by the compiler: executable('simple', files=['simple.cpp'], compile_options=[opts.define('DEBUG')]) Building libraries \u00a7 In addition to building executables, you can obviously also build libraries . This takes the same arguments as an executable as described above. Once you've defined how to build your library, you can pass it along to an executable or other shared library via the libs argument: lib = library('library', files=['library.cpp']) executable('program', files=['program.cpp'], libs=[lib]) By default, this will create a shared library; however, when running bfg9000, users can specify what kind of library to build by passing --enable-shared / --disable-shared and --enable-static / --disable-static on the command line. When creating a static library, the link_options argument behaves specially: it represents arguments that will be forwarded to the dynamic linker when the static lib is used. Shared and static libraries \u00a7 Sometimes, you may want to explicitly specify in the build file whether to create a shared or a static library. This is easy to accomplish: shared = shared_library('shared', files=['shared.cpp']) static = static_library('static', files=['static.cpp']) Building libraries on Windows \u00a7 On Windows, native shared libraries need to annotate public symbols so that the dynamic linker knows what to do. To facilitate this, bfg9000 automatically defines a preprocessor macro named for native-runtime languages (e.g. C or C++) when building on Windows. For shared libraries, it defines LIB<NAME>_EXPORTS ; for static, LIB<NAME>_STATIC . The following snippet shows how you can use these macros to set the appropriate attributes for your public symbols: #if defined(_WIN32) && !defined(LIBLIBRARY_STATIC) # ifdef LIBLIBRARY_EXPORTS # define LIB_PUBLIC __declspec(dllexport) # else # define LIB_PUBLIC __declspec(dllimport) # endif #else # define LIB_PUBLIC #endif Generated sources \u00a7 In addition to compiling and linking, many build involve a source-generation step, e.g. generating lexers/parsers via Lex/Yacc. bfg9000 tries to make this as simple as possible. Much like how executable() (and library() , etc) will automatically invoke object_files as needed to create the compilation steps, bfg9000 will automatically add the appropriate generated_source() calls where possible. Here, since 'qml.qrc' can be auto-detected as a Qt QRC file, the 'qml.cpp' file will be created and passed on to the implicit object_file call: executable('qtprog', ['main.cpp', 'qml.qrc'], ...) However, there are situations where this doesn't work automatically. Some source-generation steps, such as Yacc, output multiple files, so they can't be invoked implicitly: parse, parse_h = generated_source(file='calc.y') executable('calc', files=[parse, ...], includes=[parse_h]) In addition, bfg9000 can only invoke generated_source() automatically when the file is passed as the source to be compiled by object_file . Using a Qt UI file, for example, requires explicitly generating the source: widget = generated_source('widget.ui') executable('qtprog, ['main.cpp'], includes=[widget], ...) Finally, some source-generators don't have their own unique file extensions, so it's not possible to automatically detect their language. In this case, you can either explicitly call generated_source() or create the file object with the appropriate language, e.g.: auto_file('window.hpp', lang='qtmoc') . Finding files \u00a7 For projects with many source files, it can be inconvenient to manually list all of them. Since build.bfg files are just Python scripts, you could use Python's standard library to examine the file system and build the list. However, there's a better way: bfg9000 provides a find_files() function to fetch the list; if the list ever changes, the build files will be regenerated automatically the next time they're run. find_files() starts at a base directory and searches recursively for any files matching a particular glob: hello_files = find_files('src/hello/**/*.cpp') executable('hello', files=hello_files) There are lots of options you can pass to find_files() to tweak its behavior. For instance, you can exclude certain files or directories by passing a glob to the exclude argument. Default targets \u00a7 When you're building multiple binaries, you might want to be able to specify what gets built by default, i.e. when calling make (or ninja ) with no arguments. Normally, every executable and library (except those passed to test() ) will get built. However, you can pass any build steps to default() , and they'll be set as the default, overriding the normal behavior. This makes it easy to provide your users with a standard build that gets them all the bits they need, and none they don't. External packages \u00a7 Most non-trivial projects have external package dependencies. These can be specified in a build.bfg file via package() and used when building binaries by passing them in the packages argument: ogg = package('ogg', kind='static') prog_opts = package('boost', 'program_options', version='>=1.55') executable('program', files=['main.cpp'], packages=[ogg, prog_opts]) There are many different ways external packages are distributed, but for native packages (C, C++, Fortran, etc), this is handled via mopack . mopack provides a variety of ways to resolve external packages, and bfg9000 will automatically invoke mopack during configuration. You can specify how each package dependency should be resolved via an mopack.yml file: packages: foobar: origin: tarball path: foobar-1.0.tar.gz build: bfg9000 By keeping the package resolution metadata separate from the build.bfg file, it's much easier for people building your project to override how package dependencies are resolved. Installation \u00a7 After building, you might want to allow your project to be installed onto the user's system somewhere. Most files (headers, executables, libraries) can be added to the list of installed files via the install() function. You can also install entire directories of headers: include_dir = header_directory('include') lib = static_library('program', files=['src/prog.cpp'], includes=[include_dir]) install(lib, include_dir) Tests \u00a7 All good projects should have tests. Since your project is good (isn't it?), yours has tests too, and you should have a good way to execute those tests from your build system. bfg9000 provides a set of functions for running tests. The most important of these is aptly named test() . Any executable can be passed to this function, and it will be executed as a test; an exit status of 0 marks success, and non-zero marks failure: test( executable('test_foo', files=['test_foo.cpp']) ) In addition, you can provide a test driver that collects all of your tests together and runs them as one. test_driver() takes an executable (a system_executable by default) that runs all the test files. This allows you to aggregate multiple test files into a single run, which is very useful for reporting: mettle = test_driver('mettle') test( executable('test_foo', files=['test_foo.cpp']), driver=mettle ) test( executable('test_bar', files=['test_bar.cpp']), driver=mettle ) Aliases \u00a7 Sometimes, you just want to group a set of targets together to make it easier to build all of them at once. This automatically happens for default targets by creating an all alias, but you can do this yourself for any collection of targets: foo = executable('foo', files=['foo.cpp']) bar = executable('bar', files=['bar.cpp']) alias('foobar', [foo, bar]) Commands \u00a7 In addition to ordinary build steps, it can be useful to provide other common commands that apply to a project's source, such as linting the code or building documentation. Normally, you should pass the command to be run as an array of arguments. This will automatically handle escaping any quotes in each argument. This is especially important for cross-platform compatibility, since different shells have different quoting rules: command('hello', cmd=['python', '-c', 'print(\"hello\")']) Of course, if you need to use your shell's special characters (like && ), you can simply pass a string to the cmd argument. In addition, you can supply multiple commands to this function via the cmds argument: command('script', cmds=[ 'touch file', ['python', 'script.py'] ]) Submodules \u00a7 For larger projects, putting all of your build configuration in a single file can be difficult to maintain. Instead, you can split your configuration into multiple submodules. The submodule function will execute the build.bfg file (or options.bfg file when applicable ) in the specified directory and return any exported objects as a dict to be used in the parent module. The submodule can then call the export function to return any relevant objects (e.g. built files) to the parent module: # In main build.bfg: sub = submodule('dir') executable('exe', ['exe.cpp'], libs=[sub['library']]) # In sub/build.bfg: lib = library('mylib', ['mylib.cpp']) export(library=lib) Within a submodule, all paths for inputs (source files) and outputs (built files) are relative to the directory containing the submodule's build.bfg file. (If you need to reference a file outside of the submodule's directory, you can simply prefix your path with ../ ): # In sub/build.bfg: # Builds $(builddir)/libmylib.so (or similar) from $(srcdir)/sub/mylib.cpp: library('../mylib', ['mylib.cpp']) Custom build steps \u00a7 Sometimes, the built-in build steps don't support the things you want to do (e.g. if you're generating source files via Flex/Bison). In these cases, you can use build_step() to define a step that produces a file by running an arbitrary command: lex = build_step('lex.yy.c', cmd=[ 'flex', source_file('hello.lex') ]) To reduce repetition, you can also use the build_step.input and build_step.output placeholders in your command. lex = build_step('hello-lex.c', cmd=[ 'flex', build_step.input, '-o' build_step.output ], files=['hello.lex']) By default, the output of a custom build step is passed through auto_file , which produces a source file, header file, or a generic file based on the path's extension. When this doesn't produce the expected results, you can supply the type argument, which lets you pass a function taking a path and returning a file object to represent the output: libfoo = shared_library(...) stripped = build_step('libfoo.so', cmd=[ 'strip', '-o', build_step.output, libfoo ], type=shared_library) Finally, you can define steps that produce multiple files by passing a list of names as the outputs of the step. This will then return a file object for each of the outputs: hdr, src = build_step(['hello.tab.h', 'hello.tab.c'], cmd=[ 'bison', source_file('hello.y') ]) When producing multiple files via build_step , the type argument can be passed as either a single function (which will be applied to every output) or as a list of function (which will be applied element-wise to each output). User-defined arguments \u00a7 Many projects benefit from letting the user configure project-specific elements of their builds, e.g. by enabling certain optional features or by using different branding for testing and release builds. You can add support for options to configure your build by creating a options.bfg file alongside your build.bfg . Inside options.bfg , you can define arguments with the argument() function: # Adds --name/--x-name to the list of available command-line options, e.g.: # 9k build/ --name=foobar argument('name', default='unnamed', help=\"set the program's name\") It works much like argparse 's add_argument() method, except that a) argument names are automatically prefixed with -- (and --x- for forwards compatibility) and b) there are two extra actions available: enable' and 'with' : # Adds --enable-foo/--disable-foo (and --x- variants) argument('foo', action='enable', help='enable the foo feature') # Adds --with-bar/--without-bar (and --x- variants) argument('bar', action='with', help='build the bar module') Once these options are defined, you can fetch their results from the built-in argv global in your build.bfg file. This object is simply an argparse.Namespace object: print(\"This program's name is {}\".format(argv.name)) if argv.foo: pass # Enable the foo feature if argv.bar: pass # Build the bar module Generating pkg-config data \u00a7 When creating libraries for other projects to use, pkg-config is a common tool to simplify using the library. pkg-config allows users to look up a package and retrieve all the compiler and linker options required to use that package. You can generate a pkg-config .pc file using the pkg_config() function: project('my_project', '1.0') include = header_directory('include', include='*.hpp') lib = library('hello', files=['src/hello.cpp'], includes=[include]) install(lib, include) pkg_config( 'my_pkgconfig_project', version='2.0', includes=[include], libs=[lib], ) If the auto_fill parameter is True , this function will automatically fill in the values for the package's name, version, installed include directories, and installed libraries: pkg_config(auto_fill=True) You can even use the pkg-config package you just created when building other binaries. However, this is only allowed when auto_fill is False , since bfg9000 won't know what an auto-filled pkg-config .pc file would look like until after the build script is finished: my_pkg = pkg_config( # ... ) executable('prog', 'prog.cpp', packages=[my_pkg]) Libraries are perhaps the most interesting part of the pkg_config() function. If a library listed here depends on any packages or other libraries, they will automatically be included in the pkg-config info. There are several other options available to tweak the output of this function, detailed in the reference guide .","title":"Writing a Build File"},{"location":"user/writing/#writing-a-build-file","text":"bfg9000's build script is called build.bfg and is (usually) placed in the root of your source tree. build.bfg files are just Python scripts with a handful of extra built-in functions to define all the steps for building your software. While bfg9000's goal is to make writing build scripts easy, sometimes complexity is unavoidable. By using a general-purpose language, this complexity can (hopefully!) be managed.","title":"Writing a Build File"},{"location":"user/writing/#your-first-build-script","text":"The simplest build script, compiling a single source file into an executable , is indeed very simple: executable('simple', files=['simple.cpp']) The above is all you need to build your executable for any supported build backend and platform. The output file's name is automatically converted to the appropriate name for the target platform ( 'simple' on Linux and OS X and 'simple.exe' on Windows).","title":"Your first build script"},{"location":"user/writing/#logging-messages","text":"Sometimes, it can be helpful to display messages to the user when they're building your project. While print , sys.stdout , and the like work, these aren't integrated into bfg9000's logging system. Instead, you can use info() , warning() , or debug() to log your messages: try: pkg = package('optional_dependency') except PackageResolutionError: warning('optional_dependency not found; fancy-feature disabled')","title":"Logging messages"},{"location":"user/writing/#building-executables","text":"We've already seen how to build simple executables, but build tools aren't much good if that's all they can do! Naturally, it's easy to build an executable from multiple source files (just add more elements to the files argument), but there are plenty of other things you'd probably like to do with your build scripts.","title":"Building executables"},{"location":"user/writing/#implicit-conversions","text":"bfg9000 tries its best to make your build scripts easy to read and to minimize verbosity. First, arguments that normally take a list can take a single item instead, e.g. executable('simple', files='simple.cpp') . In addition, bfg9000 will automatically convert a string argument to an object of the appropriate type. In the previous example, 'simple.cpp' is automatically passed to object_files , which in turn converts it to a source_file and generates the appropriate build step.","title":"Implicit conversions"},{"location":"user/writing/#subdirectories","text":"Many projects organize their headers and source files into different directories. For source files, this is easy to handle: just write out the relative path to the file. For header files, you need to let your compiler know where they're located. The header_directory function creates a reference to the directory, which can then be passed to your build function via the include argument: include_dir = header_directory('include') executable('program', files=['src/prog.cpp'], includes=[include_dir]) As noted above, you can also simplify this to: executable('program', files='src/prog.cpp', includes='include') Of course, bfg9000 also allows you to place built files in subdirectories as well. Simply specify the relative path as the name of executable (or whatever type of file you're building).","title":"Subdirectories"},{"location":"user/writing/#options","text":"Build scripts often need to set options when compiling/linking binaries. Sometimes, these are specific to a single executable in the project, and other times they apply to all the binaries. bfg9000 supports both cases. You can provide options for a single binary with the compile_options and link_options arguments: executable('simple', files=['simple.cpp'], compile_options=['-Wall', '-Werror'], link_options=['-static-libstdc++']) You can also specify global compiler options (on a per-language basis) as well as global linker options : global_options(['-Wall', '-Werror'], lang='c++') global_link_options(['-static-libstdc++']) In addition to passing options as lists as above, you can also pass them as a single string, which will be split according to the rules for sh-style command line arguments.","title":"Options"},{"location":"user/writing/#semantic-options","text":"Naturally, the interpretations of these options depend on the compiler (or linker!) being used. One method is simply to the kind of compiler being used and supply the appropriate option strings. You can do this by consulting the build's Environment and checking the compiler's flavor . However, it's often better to use semantic options , options that are defined as objects which will automatically be interpreted by the compiler: executable('simple', files=['simple.cpp'], compile_options=[opts.define('DEBUG')])","title":"Semantic options"},{"location":"user/writing/#building-libraries","text":"In addition to building executables, you can obviously also build libraries . This takes the same arguments as an executable as described above. Once you've defined how to build your library, you can pass it along to an executable or other shared library via the libs argument: lib = library('library', files=['library.cpp']) executable('program', files=['program.cpp'], libs=[lib]) By default, this will create a shared library; however, when running bfg9000, users can specify what kind of library to build by passing --enable-shared / --disable-shared and --enable-static / --disable-static on the command line. When creating a static library, the link_options argument behaves specially: it represents arguments that will be forwarded to the dynamic linker when the static lib is used.","title":"Building libraries"},{"location":"user/writing/#shared-and-static-libraries","text":"Sometimes, you may want to explicitly specify in the build file whether to create a shared or a static library. This is easy to accomplish: shared = shared_library('shared', files=['shared.cpp']) static = static_library('static', files=['static.cpp'])","title":"Shared and static libraries"},{"location":"user/writing/#building-libraries-on-windows","text":"On Windows, native shared libraries need to annotate public symbols so that the dynamic linker knows what to do. To facilitate this, bfg9000 automatically defines a preprocessor macro named for native-runtime languages (e.g. C or C++) when building on Windows. For shared libraries, it defines LIB<NAME>_EXPORTS ; for static, LIB<NAME>_STATIC . The following snippet shows how you can use these macros to set the appropriate attributes for your public symbols: #if defined(_WIN32) && !defined(LIBLIBRARY_STATIC) # ifdef LIBLIBRARY_EXPORTS # define LIB_PUBLIC __declspec(dllexport) # else # define LIB_PUBLIC __declspec(dllimport) # endif #else # define LIB_PUBLIC #endif","title":"Building libraries on Windows"},{"location":"user/writing/#generated-sources","text":"In addition to compiling and linking, many build involve a source-generation step, e.g. generating lexers/parsers via Lex/Yacc. bfg9000 tries to make this as simple as possible. Much like how executable() (and library() , etc) will automatically invoke object_files as needed to create the compilation steps, bfg9000 will automatically add the appropriate generated_source() calls where possible. Here, since 'qml.qrc' can be auto-detected as a Qt QRC file, the 'qml.cpp' file will be created and passed on to the implicit object_file call: executable('qtprog', ['main.cpp', 'qml.qrc'], ...) However, there are situations where this doesn't work automatically. Some source-generation steps, such as Yacc, output multiple files, so they can't be invoked implicitly: parse, parse_h = generated_source(file='calc.y') executable('calc', files=[parse, ...], includes=[parse_h]) In addition, bfg9000 can only invoke generated_source() automatically when the file is passed as the source to be compiled by object_file . Using a Qt UI file, for example, requires explicitly generating the source: widget = generated_source('widget.ui') executable('qtprog, ['main.cpp'], includes=[widget], ...) Finally, some source-generators don't have their own unique file extensions, so it's not possible to automatically detect their language. In this case, you can either explicitly call generated_source() or create the file object with the appropriate language, e.g.: auto_file('window.hpp', lang='qtmoc') .","title":"Generated sources"},{"location":"user/writing/#finding-files","text":"For projects with many source files, it can be inconvenient to manually list all of them. Since build.bfg files are just Python scripts, you could use Python's standard library to examine the file system and build the list. However, there's a better way: bfg9000 provides a find_files() function to fetch the list; if the list ever changes, the build files will be regenerated automatically the next time they're run. find_files() starts at a base directory and searches recursively for any files matching a particular glob: hello_files = find_files('src/hello/**/*.cpp') executable('hello', files=hello_files) There are lots of options you can pass to find_files() to tweak its behavior. For instance, you can exclude certain files or directories by passing a glob to the exclude argument.","title":"Finding files"},{"location":"user/writing/#default-targets","text":"When you're building multiple binaries, you might want to be able to specify what gets built by default, i.e. when calling make (or ninja ) with no arguments. Normally, every executable and library (except those passed to test() ) will get built. However, you can pass any build steps to default() , and they'll be set as the default, overriding the normal behavior. This makes it easy to provide your users with a standard build that gets them all the bits they need, and none they don't.","title":"Default targets"},{"location":"user/writing/#external-packages","text":"Most non-trivial projects have external package dependencies. These can be specified in a build.bfg file via package() and used when building binaries by passing them in the packages argument: ogg = package('ogg', kind='static') prog_opts = package('boost', 'program_options', version='>=1.55') executable('program', files=['main.cpp'], packages=[ogg, prog_opts]) There are many different ways external packages are distributed, but for native packages (C, C++, Fortran, etc), this is handled via mopack . mopack provides a variety of ways to resolve external packages, and bfg9000 will automatically invoke mopack during configuration. You can specify how each package dependency should be resolved via an mopack.yml file: packages: foobar: origin: tarball path: foobar-1.0.tar.gz build: bfg9000 By keeping the package resolution metadata separate from the build.bfg file, it's much easier for people building your project to override how package dependencies are resolved.","title":"External packages"},{"location":"user/writing/#installation","text":"After building, you might want to allow your project to be installed onto the user's system somewhere. Most files (headers, executables, libraries) can be added to the list of installed files via the install() function. You can also install entire directories of headers: include_dir = header_directory('include') lib = static_library('program', files=['src/prog.cpp'], includes=[include_dir]) install(lib, include_dir)","title":"Installation"},{"location":"user/writing/#tests","text":"All good projects should have tests. Since your project is good (isn't it?), yours has tests too, and you should have a good way to execute those tests from your build system. bfg9000 provides a set of functions for running tests. The most important of these is aptly named test() . Any executable can be passed to this function, and it will be executed as a test; an exit status of 0 marks success, and non-zero marks failure: test( executable('test_foo', files=['test_foo.cpp']) ) In addition, you can provide a test driver that collects all of your tests together and runs them as one. test_driver() takes an executable (a system_executable by default) that runs all the test files. This allows you to aggregate multiple test files into a single run, which is very useful for reporting: mettle = test_driver('mettle') test( executable('test_foo', files=['test_foo.cpp']), driver=mettle ) test( executable('test_bar', files=['test_bar.cpp']), driver=mettle )","title":"Tests"},{"location":"user/writing/#aliases","text":"Sometimes, you just want to group a set of targets together to make it easier to build all of them at once. This automatically happens for default targets by creating an all alias, but you can do this yourself for any collection of targets: foo = executable('foo', files=['foo.cpp']) bar = executable('bar', files=['bar.cpp']) alias('foobar', [foo, bar])","title":"Aliases"},{"location":"user/writing/#commands","text":"In addition to ordinary build steps, it can be useful to provide other common commands that apply to a project's source, such as linting the code or building documentation. Normally, you should pass the command to be run as an array of arguments. This will automatically handle escaping any quotes in each argument. This is especially important for cross-platform compatibility, since different shells have different quoting rules: command('hello', cmd=['python', '-c', 'print(\"hello\")']) Of course, if you need to use your shell's special characters (like && ), you can simply pass a string to the cmd argument. In addition, you can supply multiple commands to this function via the cmds argument: command('script', cmds=[ 'touch file', ['python', 'script.py'] ])","title":"Commands"},{"location":"user/writing/#submodules","text":"For larger projects, putting all of your build configuration in a single file can be difficult to maintain. Instead, you can split your configuration into multiple submodules. The submodule function will execute the build.bfg file (or options.bfg file when applicable ) in the specified directory and return any exported objects as a dict to be used in the parent module. The submodule can then call the export function to return any relevant objects (e.g. built files) to the parent module: # In main build.bfg: sub = submodule('dir') executable('exe', ['exe.cpp'], libs=[sub['library']]) # In sub/build.bfg: lib = library('mylib', ['mylib.cpp']) export(library=lib) Within a submodule, all paths for inputs (source files) and outputs (built files) are relative to the directory containing the submodule's build.bfg file. (If you need to reference a file outside of the submodule's directory, you can simply prefix your path with ../ ): # In sub/build.bfg: # Builds $(builddir)/libmylib.so (or similar) from $(srcdir)/sub/mylib.cpp: library('../mylib', ['mylib.cpp'])","title":"Submodules"},{"location":"user/writing/#custom-build-steps","text":"Sometimes, the built-in build steps don't support the things you want to do (e.g. if you're generating source files via Flex/Bison). In these cases, you can use build_step() to define a step that produces a file by running an arbitrary command: lex = build_step('lex.yy.c', cmd=[ 'flex', source_file('hello.lex') ]) To reduce repetition, you can also use the build_step.input and build_step.output placeholders in your command. lex = build_step('hello-lex.c', cmd=[ 'flex', build_step.input, '-o' build_step.output ], files=['hello.lex']) By default, the output of a custom build step is passed through auto_file , which produces a source file, header file, or a generic file based on the path's extension. When this doesn't produce the expected results, you can supply the type argument, which lets you pass a function taking a path and returning a file object to represent the output: libfoo = shared_library(...) stripped = build_step('libfoo.so', cmd=[ 'strip', '-o', build_step.output, libfoo ], type=shared_library) Finally, you can define steps that produce multiple files by passing a list of names as the outputs of the step. This will then return a file object for each of the outputs: hdr, src = build_step(['hello.tab.h', 'hello.tab.c'], cmd=[ 'bison', source_file('hello.y') ]) When producing multiple files via build_step , the type argument can be passed as either a single function (which will be applied to every output) or as a list of function (which will be applied element-wise to each output).","title":"Custom build steps"},{"location":"user/writing/#user-defined-arguments","text":"Many projects benefit from letting the user configure project-specific elements of their builds, e.g. by enabling certain optional features or by using different branding for testing and release builds. You can add support for options to configure your build by creating a options.bfg file alongside your build.bfg . Inside options.bfg , you can define arguments with the argument() function: # Adds --name/--x-name to the list of available command-line options, e.g.: # 9k build/ --name=foobar argument('name', default='unnamed', help=\"set the program's name\") It works much like argparse 's add_argument() method, except that a) argument names are automatically prefixed with -- (and --x- for forwards compatibility) and b) there are two extra actions available: enable' and 'with' : # Adds --enable-foo/--disable-foo (and --x- variants) argument('foo', action='enable', help='enable the foo feature') # Adds --with-bar/--without-bar (and --x- variants) argument('bar', action='with', help='build the bar module') Once these options are defined, you can fetch their results from the built-in argv global in your build.bfg file. This object is simply an argparse.Namespace object: print(\"This program's name is {}\".format(argv.name)) if argv.foo: pass # Enable the foo feature if argv.bar: pass # Build the bar module","title":"User-defined arguments"},{"location":"user/writing/#generating-pkg-config-data","text":"When creating libraries for other projects to use, pkg-config is a common tool to simplify using the library. pkg-config allows users to look up a package and retrieve all the compiler and linker options required to use that package. You can generate a pkg-config .pc file using the pkg_config() function: project('my_project', '1.0') include = header_directory('include', include='*.hpp') lib = library('hello', files=['src/hello.cpp'], includes=[include]) install(lib, include) pkg_config( 'my_pkgconfig_project', version='2.0', includes=[include], libs=[lib], ) If the auto_fill parameter is True , this function will automatically fill in the values for the package's name, version, installed include directories, and installed libraries: pkg_config(auto_fill=True) You can even use the pkg-config package you just created when building other binaries. However, this is only allowed when auto_fill is False , since bfg9000 won't know what an auto-filled pkg-config .pc file would look like until after the build script is finished: my_pkg = pkg_config( # ... ) executable('prog', 'prog.cpp', packages=[my_pkg]) Libraries are perhaps the most interesting part of the pkg_config() function. If a library listed here depends on any packages or other libraries, they will automatically be included in the pkg-config info. There are several other options available to tweak the output of this function, detailed in the reference guide .","title":"Generating pkg-config data"}]}